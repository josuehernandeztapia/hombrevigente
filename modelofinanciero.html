<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Modelo Financiero - Hombre Vigente V51.0</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
<!-- Lucide Icons for a professional touch -->
<script src="https://unpkg.com/lucide@latest"></script>
<style>
/* Base Styles - Adjusted for "Hombre Vigente" Look & Feel */
body {
    font-family: 'Inter', sans-serif;
    background-color: #111827; /* gray-900 for a slightly softer dark background */
    color: #e2e8f0; /* slate-200 for main text */
    overflow-x: hidden; /* Prevent horizontal scroll */
}
h1, h2, h3, h4 {
    color: #f9fafb; /* gray-50 for titles */
    font-weight: 700;
}
/* Gradient text highlight to match the blue in the logo */
.highlight-text {
    background: -webkit-linear-gradient(45deg, #3b82f6, #60a5fa); /* blue-500 to blue-400 */
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
/* Tabs Navigation */
.tab-button {
    transition: all 0.3s ease;
    cursor: pointer;
    padding: 0.75rem 1.25rem;
    border-bottom: 2px solid transparent;
    color: #9ca3af; /* gray-400 */
    font-weight: 500;
    margin-right: 0.5rem;
    border-radius: 0.5rem 0.5rem 0 0;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
}
.tab-button.active {
    border-color: #3b82f6; /* blue-500 */
    color: #f9fafb; /* gray-50 */
    background-color: #1f2937; /* gray-800 */
    font-weight: 600;
}
.tab-button:hover:not(.active) {
    color: #d1d5db; /* gray-300 */
    background-color: #1f2937; /* gray-800 */
}
/* Section content */
.content-section { display: none; }
.content-section.active { display: block; }
/* Card Style */
.card {
    background-color: #1f2937; /* gray-800 for card interior */
    border-radius: 0.75rem; /* rounded-xl */
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    border: 1px solid #374151; /* gray-700 for subtle borders */
}
/* Sliders */
.input-slider {
    -webkit-appearance: none;
    width: 100%;
    height: 8px;
    background: #374151; /* gray-700 */
    border-radius: 9999px;
    outline: none;
    transition: background 0.2s ease-in-out;
}
.input-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: #3b82f6; /* blue-500 */
    border-radius: 9999px;
    cursor: pointer;
    box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.3); /* Ring when dragging */
    transition: background 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.input-slider:hover::-webkit-slider-thumb {
    background: #60a5fa; /* blue-400 */
}
/* Financial Tables */
.financial-table {
    width: 100%;
    border-collapse: collapse;
    background-color: #1f2937; /* gray-800 */
    border-radius: 0.75rem;
    overflow: hidden;
}
.financial-table th, .financial-table td {
    padding: 1rem;
    text-align: right;
    border-bottom: 1px solid #374151; /* gray-700 */
    font-size: 0.95rem;
}
.financial-table th {
    background-color: #374151; /* gray-700 */
    font-weight: 600;
    color: #9ca3af; /* gray-400 */
    text-transform: uppercase;
    letter-spacing: 0.05em;
}
.financial-table td:first-child, .financial-table th:first-child {
    text-align: left;
    color: #e5e7eb; /* gray-200 */
}
.financial-table tr:last-child td {
    border-bottom: none;
}
.financial-table tr.total-row {
    background-color: #374151; /* gray-700 */
    color: #f9fafb; /* gray-50 */
    font-weight: 700;
}
.financial-table tr.net-revenue-row {
    font-weight: 600;
}
.financial-table tr.sub-row td:first-child {
    padding-left: 2.5rem;
}
.financial-table tr.sub-sub-row td:first-child {
    padding-left: 4rem;
}
.financial-table tr.sub-sub-sub-row td:first-child {
    padding-left: 5.5rem;
}
.financial-table tr.expandable {
    cursor: pointer;
}
.financial-table tr.expandable:hover {
    background-color: #374151;
}
.financial-table .expand-icon {
    display: inline-block;
    margin-right: 0.5rem;
    transition: transform 0.2s;
}
.financial-table tr.expanded .expand-icon {
    transform: rotate(90deg);
}
.positive { color: #34d399; }
.negative { color: #f43f5e; }
/* Debug Panel */
.debug-info {
    background: #1f2937; /* gray-800 */
    color: #f9fafb; /* gray-50 */
    border: 1px solid #4b5563; /* gray-600 */
    border-radius: 0.5rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
}
/* Tooltips */
[data-tooltip] {
    position: relative;
    cursor: help;
}
[data-tooltip]:before, [data-tooltip]:after {
    position: absolute;
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    pointer-events: none;
    background-color: #1f2937;
    color: #f9fafb;
    border: 1px solid #374151;
    border-radius: 0.5rem;
    font-size: 0.8rem;
    line-height: 1.4;
    padding: 0.75rem;
    width: 280px;
    z-index: 100;
    white-space: pre-wrap;
}
[data-tooltip]:before {
    content: attr(data-tooltip);
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
}
[data-tooltip]:after {
    content: '';
    bottom: 125%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: #1f2937 transparent transparent transparent;
    transform: translateY(100% + 5px) translateX(-50%);
}
[data-tooltip]:hover:before, [data-tooltip]:hover:after {
    visibility: visible;
    opacity: 1;
}
/* Inputs and Selects */
input[type="number"], input[type="range"], input[type="text"], select {
    background-color: #374151; /* gray-700 */
    border-color: #4b5563; /* gray-600 */
    color: #e5e7eb; /* gray-200 */
    border-radius: 0.375rem;
}
input[type="number"]:focus, input[type="text"]:focus, select:focus {
    border-color: #3b82f6; /* blue-500 */
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
    background-color: #374151;
}
/* Scenario Switcher */
.scenario-switcher {
    display: flex;
    gap: 0.5rem;
    background-color: #374151;
    padding: 0.5rem;
    border-radius: 0.5rem;
}
.scenario-switcher label {
    flex: 1;
    text-align: center;
    padding: 0.5rem;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    color: #d1d5db;
}
.scenario-switcher input[type="radio"] {
    display: none;
}
.scenario-switcher input[type="radio"]:checked + label {
    background-color: #3b82f6;
    color: #f9fafb;
    font-weight: 600;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
/* Gemini Modal Styles */
.gemini-modal-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 1040;
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(4px);
}
.gemini-modal-content {
    background-color: #1f2937;
    border: 1px solid #374151;
    border-radius: 0.75rem;
    width: 90%;
    max-width: 600px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 25px rgba(0,0,0,0.5);
}
.gemini-modal-header {
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #374151;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.gemini-modal-body {
    padding: 1.5rem;
    overflow-y: auto;
    color: #e2e8f0;
}
.gemini-modal-body h5 {
    font-size: 1.1rem;
    font-weight: 600;
    color: #f9fafb;
    margin-bottom: 0.5rem;
}
.gemini-modal-body p {
    margin-bottom: 1rem;
    line-height: 1.6;
}
.gemini-modal-footer {
    padding: 1rem 1.5rem;
    border-top: 1px solid #374151;
    text-align: right;
}
/* Loading Spinner */
.loader {
    width: 48px;
    height: 48px;
    border: 5px solid #FFF;
    border-bottom-color: #3b82f6;
    border-radius: 50%;
    display: inline-block;
    box-sizing: border-box;
    animation: rotation 1s linear infinite;
    margin: 2rem auto;
}
@keyframes rotation {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
/* V51.0 Specific Styles for IA Controls */
.ia-control-item {
    padding-bottom: 0.75rem;
    margin-bottom: 0.75rem;
    border-bottom: 1px solid #374151;
}
.ia-control-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}
.ia-control-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.25rem;
}
.ia-control-description {
    font-size: 0.8rem;
    color: #9ca3af;
    padding-right: 1rem;
}
</style>
</head>
<body>
<!-- Debug Panel -->
<div id="debug-info" class="debug-info" style="display:none; position: fixed; top: 10px; right: 10px; z-index: 1050; padding: 10px; max-height: 400px; overflow-y: auto;">
    <div id="debug-content"></div>
    <button onclick="toggleDebug()" class="bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded mt-2 text-xs">Cerrar</button>
</div>
<!-- Gemini Modal -->
<div id="gemini-modal" class="gemini-modal-backdrop" style="display: none;">
    <div class="gemini-modal-content">
        <div class="gemini-modal-header">
            <h4 id="gemini-modal-title" class="text-xl font-bold text-white"></h4>
            <button onclick="closeGeminiModal()" class="text-gray-400 hover:text-white">&times;</button>
        </div>
        <div id="gemini-modal-body" class="gemini-modal-body">
            <!-- Content will be injected here -->
        </div>
        <div id="gemini-modal-footer" class="gemini-modal-footer">
             <button onclick="closeGeminiModal()" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg font-medium">Cerrar</button>
        </div>
    </div>
</div>
<div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
    <!-- Header -->
    <header class="mb-4 text-center bg-transparent rounded-xl p-6">
        <h1 class="text-4xl lg:text-5xl font-black text-white leading-tight tracking-tighter mb-2">Modelo Financiero - <span class="highlight-text">Hombre Vigente</span></h1>
        <p class="text-xl text-slate-400 mt-2">Ecosistema Integral - IA NATIVE</p>
        <p class="text-lg text-slate-500 mt-1">V51.0 - Strategic Cockpit</p>
        <div class="flex justify-center items-center gap-4 mt-4">
            <button onclick="toggleDebug()" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg font-medium transition duration-300 inline-flex items-center gap-2">
                <i data-lucide="bug" class="w-5 h-5"></i> Debug
            </button>
            <button onclick="openCopilotModal()" class="bg-purple-600 hover:bg-purple-500 text-white px-4 py-2 rounded-lg font-medium transition duration-300 inline-flex items-center gap-2">
                <i data-lucide="sparkles" class="w-5 h-5"></i> Copiloto Estrat√©gico
            </button>
        </div>
    </header>
    
    <div class="max-w-xl mx-auto mb-6 p-4 bg-yellow-900/50 border border-yellow-700 rounded-lg text-center">
        <label for="api-key-input" class="block text-sm font-medium text-yellow-200 mb-2">Tu API Key de Gemini (Opcional)</label>
        <input type="text" id="api-key-input" class="w-full p-2 text-xs bg-gray-800 border-gray-600 rounded-md text-white" placeholder="Pega tu clave aqu√≠ si la conexi√≥n autom√°tica falla...">
        <p class="text-xs text-yellow-400 mt-2">Obt√©n tu clave gratuita en <a href="https://aistudio.google.com/app/apikey" target="_blank" class="underline">Google AI Studio</a>.</p>
    </div>
    <!-- WOW DASHBOARD - RESTRUCTURED -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
        <!-- FILA 1 -->
        <div class="card">
            <h3 class="text-xl font-semibold mb-4 text-white">          üí∞           Capital Structure</h3>
            <div class="grid grid-cols-2 gap-4">
                <div>Equity Invested: <span id="equity-invested" class="font-bold text-blue-400">$0M</span></div>
                <div class="text-sm text-slate-400">Seed: <span id="equity-seed" class="font-medium text-slate-300">$0M</span></div>
                <div>Break-Even: <span id="break-even-month" class="font-bold text-emerald-400">N/A</span></div>
                <div class="text-sm text-slate-400">Serie A: <span id="equity-series-a" class="font-medium text-slate-300">$0M</span></div>
                <div>Debt Used: <span id="debt-used" class="font-bold text-amber-400">$0M</span></div>
                <div>Self-Financed: <span id="self-financed" class="font-bold text-emerald-400">$0M</span></div>
            </div>
        </div>
        
        <div class="card">
            <h3 class="text-xl font-semibold mb-4 text-white">          üéØ           Investment Returns</h3>
            <div class="mb-4">
                <label>Exit Multiple: <input type="range" id="exit-multiple-slider" min="6" max="10" step="0.1" value="8" class="input-slider"></label>
                <span id="exit-multiple-display" class="font-bold text-blue-400">8.0x</span>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>Exit Valuation: <span id="exit-valuation" class="font-bold text-amber-400">$0B</span></div>
                <div>Money Multiple: <span id="money-multiple" class="font-bold text-blue-400">0x</span></div>
                <div>EBITDA Y5: <span id="ebitda-year5-dash" class="font-bold text-emerald-400">$0M</span></div>
                <div>Implied TIR: <span id="implied-tir" class="font-bold text-sky-400">0%</span></div>
            </div>
        </div>
    </div>
    <!-- SEGUNDA FILA -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
        <div class="card">
            <h3 class="text-xl font-semibold mb-4 text-white">          üè¢           Growth & Scale</h3>
            <div class="grid grid-cols-2 gap-4 text-sm">
                <div>Locations Y5: <span id="locations-y5" class="font-bold text-blue-400">0</span></div>
                <div id="customers-y5-wrapper" data-tooltip="">Customers Y5: <span id="customers-y5" class="font-bold text-sky-400">0</span></div>
                <div data-tooltip="" id="ltv-cac-tooltip-wrapper">LTV:CAC Ratio: <span id="ltv-cac-ratio" class="font-bold text-emerald-400">0x</span></div>
                <div>Customer Density: <span id="customer-density" class="font-bold text-blue-400">0</span>/loc</div>
                <div>LTV (Paid): <span id="ltv-value" class="font-bold text-blue-400">$0</span></div>
                <div>CAC (Paid): <span id="cac-value" class="font-bold text-blue-400">$0</span></div>
            </div>
        </div>
        
        <div class="card">
            <h3 class="text-xl font-semibold mb-4 text-white">          ü§ñ           AI & Operations</h3>
            <div class="grid grid-cols-2 gap-4">
                <div data-tooltip="Ingresos totales del A√±o 5 divididos entre el n√∫mero de sucursales al final del periodo.">Rev./Sucursal Y5: <span id="revenue-per-location" class="font-bold text-emerald-400">$0M</span></div>
                <div>Cross-sell Boost: <span id="cross-sell-boost" class="font-bold text-sky-400">+0%</span></div>
                <div>Utilization: <span id="utilization-actual" class="font-bold text-blue-400">0%</span></div>
                <div>Revenue/Customer: <span id="revenue-per-customer" class="font-bold text-blue-400">$0K</span></div>
                <div>Specialist Earnings: <span id="specialist-earnings" class="font-bold text-emerald-400">$0K</span></div>
                <div>AI Agents: <span id="agents-active" class="font-bold text-blue-400">0/6</span></div>
            </div>
        </div>
    </div>
    <!-- Tab Navigation -->
    <div class="mb-6 border-b border-gray-700">
        <nav class="flex flex-wrap -mb-px">
            <button id="tab-control" class="tab-button active"> <i data-lucide="sliders-horizontal" class="w-5 h-5"></i> Control</button>
            <button id="tab-financieros" class="tab-button"> <i data-lucide="wallet" class="w-5 h-5"></i> Financieros</button>
            <button id="tab-graficos" class="tab-button"> <i data-lucide="bar-chart-2" class="w-5 h-5"></i> Gr√°ficos</button>
        </nav>
    </div>
    <!-- Tab Content: Control -->
    <div id="content-control" class="content-section active">
        <!--   üî•   UI REORGANIZATION V51.0 -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- COLUMNA 1: Estrategia y Crecimiento -->
            <div class="space-y-6">
                <div class="card">
                    <h4 class="font-semibold text-lg mb-4 text-white">üìà Motores de Crecimiento y Escenarios</h4>
                    <div id="growth-engine-controls" class="space-y-4"></div>
                </div>
                 <div class="card">
                    <h4 class="font-semibold text-lg mb-4 text-white">üí∞ Estrategia de Capital</h4>
                    <div id="capital-strategy-controls" class="space-y-4"></div>
                </div>
            </div>
            <!-- COLUMNA 2: Operaciones y Monetizaci√≥n -->
            <div class="space-y-6">
                <div class="card">
                    <h4 class="font-semibold text-lg mb-4 text-white">‚öôÔ∏è Operaciones y CAPEX</h4>
                    <div id="operations-controls" class="space-y-4"></div>
                     <div class="mt-4 pt-4 border-t border-gray-700">
                        <div class="text-sm font-medium text-slate-300">CAPEX / Sucursal: <span id="capex-per-location-display" class="font-bold text-amber-400">$0</span></div>
                    </div>
                </div>
                 <div class="card">
                    <h4 class="font-semibold text-lg mb-4 text-white">üíµ Monetizaci√≥n</h4>
                    <div id="monetization-controls" class="space-y-4"></div>
                </div>
            </div>
            <!-- COLUMNA 3: Din√°micas de Cliente y Supuestos Base -->
            <div class="space-y-6">
                <div class="card">
                    <h4 class="font-semibold text-lg mb-4 text-white">üìà Din√°micas del Cliente</h4>
                    <div id="customer-dynamics-controls" class="space-y-4"></div>
                </div>
                <div class="card">
                    <h4 class="font-semibold text-lg mb-4 text-white">üéõÔ∏è Supuestos Base del Negocio</h4>
                    <div id="assumptions-controls" class="space-y-4"></div>
                </div>
                <div class="card">
                    <h4 class="font-semibold text-lg mb-4 text-white">ü§ñ IA Native Controls</h4>
                    <div id="ai-native-controls" class="space-y-4"></div>
                </div>
            </div>
        </div>
        <!-- RECALCULATE BUTTON -->
        <div class="text-center mt-6">
            <button onclick="forceCalculate()" class="mt-6 bg-blue-600 hover:bg-blue-500 text-white px-6 py-3 rounded-lg font-medium transition duration-300 inline-flex items-center gap-2">
                <i data-lucide="refresh-cw" class="w-5 h-5"></i> Recalcular Modelo
            </button>
        </div>
    </div>
    <!-- Tab Content: Financials -->
    <div id="content-financieros" class="content-section">
        <div class="space-y-6">
            <div class="card">
                <div class="flex justify-between items-center mb-4">
                     <h3 class="text-xl font-semibold text-white">Estado de Resultados (P&L)</h3>
                     <button onclick="generateExecutiveSummary()" class="bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded-lg font-medium transition duration-300 inline-flex items-center gap-2 text-sm">
                        <i data-lucide="file-text" class="w-4 h-4"></i> Generar Resumen Ejecutivo      ‚ú®
                    </button>
                </div>
                <div class="overflow-x-auto">
                    <table class="financial-table">
                        <thead>
                            <tr>
                                <th>Concepto</th>
                                <th>A√±o 1</th>
                                <th>A√±o 2</th>
                                <th>A√±o 3</th>
                                <th>A√±o 4</th>
                                <th>A√±o 5</th>
                            </tr>
                        </thead>
                        <tbody id="pl-table-body"></tbody>
                    </table>
                </div>
            </div>
            <div class="card">
                <h3 class="text-xl font-semibold mb-4 text-white">Flujo de Efectivo</h3>
                <div class="overflow-x-auto">
                    <table class="financial-table">
                        <thead>
                            <tr>
                                <th>Concepto</th>
                                <th>A√±o 0</th>
                                <th>A√±o 1</th>
                                <th>A√±o 2</th>
                                <th>A√±o 3</th>
                                <th>A√±o 4</th>
                                <th>A√±o 5</th>
                            </tr>
                        </thead>
                        <tbody id="cf-table-body"></tbody>
                    </table>
                </div>
            </div>
            <div class="card">
                <h3 class="text-xl font-semibold mb-4 text-white">Balance General</h3>
                <div class="overflow-x-auto">
                    <table class="financial-table">
                        <thead>
                            <tr>
                                <th>Concepto</th>
                                <th>A√±o 1</th>
                                <th>A√±o 2</th>
                                <th>A√±o 3</th>
                                <th>A√±o 4</th>
                                <th>A√±o 5</th>
                            </tr>
                        </thead>
                        <tbody id="bs-table-body"></tbody>
                    </table>
                </div>
                <div id="balance-validation" class="mt-4 text-center font-semibold p-2 rounded-lg"></div>
            </div>
        </div>
    </div>
    <!-- Tab Content: Charts -->
    <div id="content-graficos" class="content-section">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div class="card">
                <h4 class="text-lg font-semibold mb-3 text-white">Evoluci√≥n de Ingresos</h4>
                <div style="height: 320px;"><canvas id="revenueEvolutionChart"></canvas></div>
            </div>
            <div class="card">
                <h4 class="text-lg font-semibold mb-3 text-white">Rentabilidad (EBITDA y Utilidad Neta)</h4>
                <div style="height: 320px;"><canvas id="profitabilityChart"></canvas></div>
            </div>
            <div class="card">
                <h4 class="text-lg font-semibold mb-3 text-white">Crecimiento de Clientes</h4>
                <div style="height: 320px;"><canvas id="customerGrowthChart"></canvas></div>
            </div>
             <div class="card">
                <h4 class="text-lg font-semibold mb-3 text-white">Flujo de Efectivo Anual</h4>
                <div style="height: 320px;"><canvas id="cashFlowChart"></canvas></div>
            </div>
        </div>
    </div>
</div>
<script>
// Initializes Lucide icons
lucide.createIcons();
// ===================================================================
// ===== PHASE 1: CONFIGURATION AND INITIAL DATA (THE WHAT) =========
// ===================================================================
let debugLogs = [];
let charts = {};
// Global state for UI toggles
let toggleControls = {
  OptiVigenteAI: true,
  MarketingVigenteAI: true,
  PersonaVigenteAI: true,
  bnplMarketingToggle: true 
};

// V50.9: DYNAMIC CUSTOMER JOURNEY MATRICES
const customerJourneyInitial = {
    carlos: {
        "Ajuste Barba y Cejas": 0.90, "Corte de Pelo": 0.85, "Manicure Natural": 0.70, "Pedicure Natural": 0.40, "Reducci√≥n Canas": 0.60, "Tinte Natural": 0.25, "Rebaje de Vello Corporal": 0.30, "Masajes Descontracturantes": 0.20,
        "Limpieza Facial Profunda": 0.45, "Limpieza Ultrasonido": 0.35, "PRP Dermapen": 0.03, "HIFU": 0.15, "RF Microneedling": 0.08, "L√°ser CO2": 0.02,
        "Botox": 0.45, "Fillers": 0.06, "Sculptra": 0.03,
        "Lifting Hilos PDO": 0.01, "Liposucci√≥n Papada": 0.01, "Bichectom√≠a": 0.01, "Blefaroplastia": 0.02, "Lipofilling": 0.01,
        "Limpieza Dental": 0.75, "Blanqueamiento LED": 0.15, "Depilaci√≥n L√°ser": 0.60, "Bronceado UVA": 0.08
    },
    eduardo: {
        "Ajuste Barba y Cejas": 0.80, "Corte de Pelo": 0.90, "Manicure Natural": 0.30, "Pedicure Natural": 0.15, "Reducci√≥n Canas": 0.15, "Tinte Natural": 0.15, "Rebaje de Vello Corporal": 0.15, "Masajes Descontracturantes": 0.25,
        "Limpieza Facial Profunda": 0.55, "Limpieza Ultrasonido": 0.30, "PRP Dermapen": 0.01, "HIFU": 0.02, "RF Microneedling": 0.02, "L√°ser CO2": 0.0,
        "Botox": 0.08, "Fillers": 0.0, "Sculptra": 0.0,
        "Lifting Hilos PDO": 0.0, "Liposucci√≥n Papada": 0.0, "Bichectom√≠a": 0.0, "Blefaroplastia": 0.0, "Lipofilling": 0.0,
        "Limpieza Dental": 0.35, "Blanqueamiento LED": 0.05, "Depilaci√≥n L√°ser": 0.30, "Bronceado UVA": 0.02
    },
    mantenimiento: {
        "Ajuste Barba y Cejas": 1.0, "Corte de Pelo": 1.0, "Manicure Natural": 0.50, "Pedicure Natural": 0.30, "Reducci√≥n Canas": 0.30, "Tinte Natural": 0.20, "Rebaje de Vello Corporal": 0.20, "Masajes Descontracturantes": 0.20,
        "Limpieza Facial Profunda": 0.40, "Limpieza Ultrasonido": 0.25, "PRP Dermapen": 0.0, "HIFU": 0.01, "RF Microneedling": 0.0, "L√°ser CO2": 0.0,
        "Botox": 0.05, "Fillers": 0.0, "Sculptra": 0.0,
        "Lifting Hilos PDO": 0.0, "Liposucci√≥n Papada": 0.0, "Bichectom√≠a": 0.0, "Blefaroplastia": 0.0, "Lipofilling": 0.0,
        "Limpieza Dental": 0.50, "Blanqueamiento LED": 0.03, "Depilaci√≥n L√°ser": 0.20, "Bronceado UVA": 0.05
    },
    transaccional: {
        "Ajuste Barba y Cejas": 0.70, "Corte de Pelo": 0.80, "Manicure Natural": 0.25, "Pedicure Natural": 0.10, "Reducci√≥n Canas": 0.10, "Tinte Natural": 0.05, "Rebaje de Vello Corporal": 0.10, "Masajes Descontracturantes": 0.15,
        "Limpieza Facial Profunda": 0.20, "Limpieza Ultrasonido": 0.20, "PRP Dermapen": 0.0, "HIFU": 0.0, "RF Microneedling": 0.0, "L√°ser CO2": 0.0,
        "Botox": 0.0, "Fillers": 0.0, "Sculptra": 0.0,
        "Lifting Hilos PDO": 0.0, "Liposucci√≥n Papada": 0.0, "Bichectom√≠a": 0.0, "Blefaroplastia": 0.0, "Lipofilling": 0.0,
        "Limpieza Dental": 0.15, "Blanqueamiento LED": 0.0, "Depilaci√≥n L√°ser": 0.05, "Bronceado UVA": 0.02
    }
};

const customerJourneyMature = {
    carlos: { // Premium
        "Ajuste Barba y Cejas": 0.95, "Corte de Pelo": 0.95, "Manicure Natural": 0.70, "Pedicure Natural": 0.40, "Reducci√≥n Canas": 0.60, "Tinte Natural": 0.25, "Rebaje de Vello Corporal": 0.30, "Masajes Descontracturantes": 0.30,
        "Limpieza Facial Profunda": 0.70, "Limpieza Ultrasonido": 0.35, "PRP Dermapen": 0.08, "HIFU": 0.25, "RF Microneedling": 0.08, "L√°ser CO2": 0.02,
        "Botox": 0.60, "Fillers": 0.06, "Sculptra": 0.03,
        "Lifting Hilos PDO": 0.03, "Liposucci√≥n Papada": 0.03, "Bichectom√≠a": 0.01, "Blefaroplastia": 0.02, "Lipofilling": 0.01,
        "Limpieza Dental": 0.75, "Blanqueamiento LED": 0.25, "Depilaci√≥n L√°ser": 0.80, "Bronceado UVA": 0.08
    },
    eduardo: { // Evolves into "Aspiracional"
        "Ajuste Barba y Cejas": 0.75, "Corte de Pelo": 0.85, "Manicure Natural": 0.30, "Pedicure Natural": 0.15, "Reducci√≥n Canas": 0.15, "Tinte Natural": 0.15, "Rebaje de Vello Corporal": 0.15, "Masajes Descontracturantes": 0.20,
        "Limpieza Facial Profunda": 0.55, "Limpieza Ultrasonido": 0.30, "PRP Dermapen": 0.02, "HIFU": 0.08, "RF Microneedling": 0.02, "L√°ser CO2": 0.0,
        "Botox": 0.12, "Fillers": 0.0, "Sculptra": 0.0,
        "Lifting Hilos PDO": 0.0, "Liposucci√≥n Papada": 0.0, "Bichectom√≠a": 0.0, "Blefaroplastia": 0.0, "Lipofilling": 0.0,
        "Limpieza Dental": 0.35, "Blanqueamiento LED": 0.08, "Depilaci√≥n L√°ser": 0.40, "Bronceado UVA": 0.02
    },
    mantenimiento: { // Evolves into "Performance"
        "Ajuste Barba y Cejas": 1.0, "Corte de Pelo": 1.0, "Manicure Natural": 0.50, "Pedicure Natural": 0.30, "Reducci√≥n Canas": 0.30, "Tinte Natural": 0.20, "Rebaje de Vello Corporal": 0.20, "Masajes Descontracturantes": 0.35,
        "Limpieza Facial Profunda": 0.85, "Limpieza Ultrasonido": 0.25, "PRP Dermapen": 0.15, "HIFU": 0.30, "RF Microneedling": 0.0, "L√°ser CO2": 0.0,
        "Botox": 0.45, "Fillers": 0.0, "Sculptra": 0.0,
        "Lifting Hilos PDO": 0.01, "Liposucci√≥n Papada": 0.02, "Bichectom√≠a": 0.0, "Blefaroplastia": 0.0, "Lipofilling": 0.0,
        "Limpieza Dental": 0.50, "Blanqueamiento LED": 0.25, "Depilaci√≥n L√°ser": 0.70, "Bronceado UVA": 0.05
    },
    transaccional: { // Remains the same, as they don't mature, they convert or churn
        "Ajuste Barba y Cejas": 0.70, "Corte de Pelo": 0.80, "Manicure Natural": 0.25, "Pedicure Natural": 0.10, "Reducci√≥n Canas": 0.10, "Tinte Natural": 0.05, "Rebaje de Vello Corporal": 0.10, "Masajes Descontracturantes": 0.15,
        "Limpieza Facial Profunda": 0.20, "Limpieza Ultrasonido": 0.20, "PRP Dermapen": 0.0, "HIFU": 0.0, "RF Microneedling": 0.0, "L√°ser CO2": 0.0,
        "Botox": 0.0, "Fillers": 0.0, "Sculptra": 0.0,
        "Lifting Hilos PDO": 0.0, "Liposucci√≥n Papada": 0.0, "Bichectom√≠a": 0.0, "Blefaroplastia": 0.0, "Lipofilling": 0.0,
        "Limpieza Dental": 0.15, "Blanqueamiento LED": 0.0, "Depilaci√≥n L√°ser": 0.05, "Bronceado UVA": 0.02
    }
};

// Injected modelData from internal documents - V51.0 CALIBRATION
const baseModelData = {
    general: { currency: "MXN", projectionTimeline: { unit: "months", duration: 60 }, scenario: "base" },
    realismLevers: {
        funnelConversionRate: 0.70,
    },
    customerBehavior: {
        realismFactor: 1.0,
        cohortMaturityMonths: 12, 
        adherenceMultipliers: { ultra: 1.0, high: 1.0, premium: 1.0, luxury: 1.0 }
    },
    adherenceMatrix: {
        carlos: { ultra: 0.90, high: 0.75, premium: 0.60, luxury: 0.40, surgery: 0.95 },
        eduardo: { ultra: 0.85, high: 0.65, premium: 0.35, luxury: 0.15, surgery: 0.95 },
        mantenimiento: { ultra: 0.80, high: 0.50, premium: 0.15, luxury: 0.05, surgery: 0.95 },
        transaccional: { ultra: 0.70, high: 0.30, premium: 0.05, luxury: 0.02, surgery: 0.95 }
    },
    fxRates: { MXN: 1, USD: 20, COP: 3999, EUR: 22 },
    taxSettings: { isrMexico: 0.31, isrColombia: 0.35 },
    aiDefaults: {
        efficiencyUplift: 1.05,
        CACReduction: 0.10,
        aiPersonalizationUplift: 0.08, 
        crossSellBoost: 0.08
    },
    customerArchetypes: { 
        carlos: { description: "Rejuvenecedor Premium 35-50", percentage: 0.08, ltv: 32085, cacTarget: 2510, churnRate: 0.20 }, 
        eduardo: { description: "Novato Est√©tico 25-40", percentage: 0.42, ltv: 26300, cacTarget: 750, churnRate: 0.35 }, 
        transaccional: { 
            description: "Cazador Ofertas", 
            percentage: 0.22, 
            ltv: 7980, 
            cacTarget: 400, 
            churnRate: 0.70,
            conversionTo: { archetype: 'mantenimiento', rate: 0.20 },
        },
        mantenimiento: { description: "Grooming Regular", percentage: 0.28, ltv: 32980, cacTarget: 450, churnRate: 0.40 } 
    },
    marketing: {
        launchStrategy: {
            enabled: true,
            durationMonths: 6,
            seedFundingAllocation: 2485000,
            plazaLaunchBudget: 2840000,
            sucursalLaunchBudget: 750000
        },
        sustainBudgetPerLocation: 20000, 
        walkInsPerLocationPerMonth: 50 
    },
    marketingChannels: {
        carlosFunnel: { target: "carlos", cac: 1800, wordOfMouthMultiplier: 1.15 },
        eduardoFunnel: { target: "eduardo", cac: 1200, wordOfMouthMultiplier: 1.35 },
        transaccionalFunnel: { target: "transaccional", cac: 0, wordOfMouthMultiplier: 1.05 },
        mantenimientoFunnel: { target: "mantenimiento", cac: 600, wordOfMouthMultiplier: 1.20 }
    },
    pricing: {
        premiumServiceDiscount: 0.0,
        services: [ 
            { name: "HIFU", category: "Rejuvenecimiento y Facial", defaultPrice: 3800, suppliesCost: 140, tier: "premium", adherenceTier: "premium", repurchaseCycleMonths: 12, avgDurationHours: 1.5 },
            { name: "RF Microneedling", category: "Rejuvenecimiento y Facial", defaultPrice: 2800, suppliesCost: 170, tier: "premium", adherenceTier: "premium", repurchaseCycleMonths: 4, avgDurationHours: 1.0 },
            { name: "L√°ser CO2", category: "Rejuvenecimiento y Facial", defaultPrice: 4700, suppliesCost: 180, tier: "premium", adherenceTier: "luxury", revenueShare: 0.35, repurchaseCycleMonths: 12, avgDurationHours: 1.0 },
            { name: "Limpieza Facial Profunda", category: "Rejuvenecimiento y Facial", defaultPrice: 750, suppliesCost: 75, tier: "mid", adherenceTier: "high", repurchaseCycleMonths: 1.5, avgDurationHours: 1.0 },
            { name: "PRP Dermapen", category: "Rejuvenecimiento y Facial", defaultPrice: 3000, suppliesCost: 110, tier: "mid", adherenceTier: "premium", repurchaseCycleMonths: 2, avgDurationHours: 1.0 },
            { name: "Limpieza Ultrasonido", category: "Rejuvenecimiento y Facial", defaultPrice: 580, suppliesCost: 55, tier: "basic", adherenceTier: "high", repurchaseCycleMonths: 2, avgDurationHours: 0.75 },
            { name: "Botox", category: "Aplicaciones de Precisi√≥n", defaultPrice: 4800, suppliesCost: 100, tier: "premium", adherenceTier: "premium", revenueShare: 0.35, repurchaseCycleMonths: 6, avgDurationHours: 0.5 },
            { name: "Fillers", category: "Aplicaciones de Precisi√≥n", defaultPrice: 4800, suppliesCost: 140, tier: "premium", adherenceTier: "premium", revenueShare: 0.35, repurchaseCycleMonths: 9, avgDurationHours: 0.75 },
            { name: "Sculptra", category: "Aplicaciones de Precisi√≥n", defaultPrice: 11000, suppliesCost: 180, tier: "premium", adherenceTier: "luxury", revenueShare: 0.35, repurchaseCycleMonths: 1.25, avgDurationHours: 1.0 },
            { name: "Lifting Hilos PDO", category: "Procedimientos de Contorno", defaultPrice: 3800, suppliesCost: 140, tier: "premium", adherenceTier: "luxury", revenueShare: 0.35, repurchaseCycleMonths: 18, avgDurationHours: 1.5 },
            { name: "Liposucci√≥n Papada", category: "Procedimientos de Contorno", defaultPrice: 16500, suppliesCost: 8250, tier: "surgery", adherenceTier: "surgery", revenueShare: 0.50, repurchaseCycleMonths: 60, avgDurationHours: 3.0 },
            { name: "Bichectom√≠a", category: "Procedimientos de Contorno", defaultPrice: 14000, suppliesCost: 7000, tier: "surgery", adherenceTier: "surgery", revenueShare: 0.50, repurchaseCycleMonths: 60, avgDurationHours: 2.0 },
            { name: "Blefaroplastia", category: "Procedimientos de Contorno", defaultPrice: 23000, suppliesCost: 11500, tier: "surgery", adherenceTier: "surgery", revenueShare: 0.50, repurchaseCycleMonths: 60, avgDurationHours: 2.5 },
            { name: "Lipofilling", category: "Procedimientos de Contorno", defaultPrice: 14000, suppliesCost: 7000, tier: "surgery", adherenceTier: "surgery", revenueShare: 0.50, repurchaseCycleMonths: 60, avgDurationHours: 2.5 },
            { name: "Blanqueamiento LED", category: "Grooming y Wellness", defaultPrice: 3300, suppliesCost: 140, tier: "premium", adherenceTier: "premium", repurchaseCycleMonths: 8, avgDurationHours: 1.0 },
            { name: "Limpieza Dental", category: "Grooming y Wellness", defaultPrice: 1200, suppliesCost: 90, tier: "mid", adherenceTier: "ultra", repurchaseCycleMonths: 6, avgDurationHours: 0.75 },
            { name: "Depilaci√≥n L√°ser", category: "Grooming y Wellness", defaultPrice: 2300, suppliesCost: 140, tier: "mid", adherenceTier: "high", repurchaseCycleMonths: 2, avgDurationHours: 1.0 },
            { name: "Masajes Descontracturantes", category: "Grooming y Wellness", defaultPrice: 950, suppliesCost: 75, tier: "basic", adherenceTier: "high", repurchaseCycleMonths: 1, avgDurationHours: 1.0 },
            { name: "Bronceado UVA", category: "Grooming y Wellness", defaultPrice: 480, suppliesCost: 35, tier: "basic", adherenceTier: "luxury", repurchaseCycleMonths: 0.5, avgDurationHours: 0.5 },
            { name: "Corte de Pelo", category: "Grooming y Wellness", defaultPrice: 380, suppliesCost: 28, tier: "basic", adherenceTier: "ultra", repurchaseCycleMonths: 0.75, avgDurationHours: 0.75 },
            { name: "Ajuste Barba y Cejas", category: "Grooming y Wellness", defaultPrice: 280, suppliesCost: 18, tier: "basic", adherenceTier: "ultra", repurchaseCycleMonths: 0.5, avgDurationHours: 0.5 },
            { name: "Manicure Natural", category: "Grooming y Wellness", defaultPrice: 380, suppliesCost: 28, tier: "basic", adherenceTier: "ultra", repurchaseCycleMonths: 0.75, avgDurationHours: 0.5 },
            { name: "Pedicure Natural", category: "Grooming y Wellness", defaultPrice: 480, suppliesCost: 38, tier: "basic", adherenceTier: "high", repurchaseCycleMonths: 1, avgDurationHours: 0.75 },
            { name: "Tinte Natural", category: "Grooming y Wellness", defaultPrice: 620, suppliesCost: 45, tier: "basic", adherenceTier: "high", repurchaseCycleMonths: 1.5, avgDurationHours: 0.5 },
            { name: "Reducci√≥n Canas", category: "Grooming y Wellness", defaultPrice: 380, suppliesCost: 38, tier: "basic", adherenceTier: "ultra", repurchaseCycleMonths: 1, avgDurationHours: 0.5 },
            { name: "Rebaje de Vello Corporal", category: "Grooming y Wellness", defaultPrice: 1000, suppliesCost: 50, tier: "basic", adherenceTier: "high", repurchaseCycleMonths: 1, avgDurationHours: 0.75 }
        ],
        membership: {
            access: { price: 1400, targetArchetype: ["eduardo", "mantenimiento"], adoptionRate: 0.35, behaviorChanges: { churnReduction: 0.20 }, discountRate: 0.15 },
            elite: { price: 3800, targetArchetype: ["carlos"], adoptionRate: 0.15, behaviorChanges: { churnReduction: 0.35 }, discountRate: 0.20 }
        },
        bnpl: {
            enabled: true,
            marketingEnabled: true,
            revenueUpliftMultiplier: 1.25,
            minPriceThreshold: 2500 
        }
    },
    expansionPlan: {
        enabled: true,
        expansionSchedule: [
            { month: 1,  city: "QRO", monthsSinceOpening: 0 }, 
            { month: 13, city: "MTY", monthsSinceOpening: 0 }, 
            { month: 18, city: "CDMX", monthsSinceOpening: 0 },
            { month: 24, city: "GDL", monthsSinceOpening: 0 }, 
            { month: 28, city: "QRO", monthsSinceOpening: 0 }, 
            { month: 32, city: "MTY", monthsSinceOpening: 0 },
            { month: 36, city: "CDMX", monthsSinceOpening: 0 }, 
            { month: 39, city: "CDMX", monthsSinceOpening: 0 }, 
            { month: 42, city: "MTY", monthsSinceOpening: 0 },
            { month: 45, city: "GDL", monthsSinceOpening: 0 }, 
            { month: 48, city: "CUN", monthsSinceOpening: 0 }, 
            { month: 51, city: "CDMX", monthsSinceOpening: 0 },
            { month: 54, city: "MTY", monthsSinceOpening: 0 }, 
            { month: 57, city: "BOG", monthsSinceOpening: 0 }
        ]
    },
    opexSucursal: {
        labor: {
            concierge: { salary: 12000, commissions: { retentionBonus: 2000, upsellRate: 0.02 } },
            medicoEsteticista: { salary: 0, revenueShare: 0.50, minMonthlyGuarantee: 25000 },
            operario: { salary: 14000 },
            cirujanoPlastico: { salary: 0, revenueShare: 0.60 }
        },
        staffRatios: { operariosPerRoom: 1.0, medicoPerSession: 0.01, conciergePerClient: 0.02 },
        energy: { fixedMonthlyKwh: 1000, costPerKwh: 4.5 },
        rentaMensual: 40000, 
        adminLocalMonthly: 10000
    },
    capacity: {
        treatmentRooms: 5, dailyOperatingHours: 12, daysOpenPerMonth: 26, targetUtilization: 0.70,
        activeSucursales: 1,
        surgicalSuite: 1,
        maxSurgeriesPerMonth: 10, 
        get maxHoursPerMonth() { return this.treatmentRooms * this.dailyOperatingHours * this.daysOpenPerMonth * this.activeSucursales; }
    },
    capexSucursal: {
        remodelCostPerM2: 15000, 
        clinicSizeM2: 250,
        equipmentStrategy: "nuevo", 
        equipmentList: [
            { category: "CORE M√âDICO-EST√âTICO", name: "HIFU (Ultraformer III)", priceNew: 525000, priceReacondicionado: 285000, vidaUtilAnios: 5, maintenanceRate: 0.06 },
            { category: "CORE M√âDICO-EST√âTICO", name: "L√°ser Fraccional CO2", priceNew: 500000, priceReacondicionado: 400000, vidaUtilAnios: 5, maintenanceRate: 0.08 },
            { category: "CORE M√âDICO-EST√âTICO", name: "RF Microneedling (Morpheus8)", priceNew: 350000, priceReacondicionado: 62500, vidaUtilAnios: 5, maintenanceRate: 0.07 },
            { category: "CORE M√âDICO-EST√âTICO", name: "L√°ser Nd:YAG", priceNew: 400000, priceReacondicionado: 150000, vidaUtilAnios: 5, maintenanceRate: 0.05 },
            { category: "CORE M√âDICO-EST√âTICO", name: "Liposuctor (VASER)", priceNew: 175000, priceReacondicionado: 140000, vidaUtilAnios: 5, maintenanceRate: 0.05 },
            { category: "CORE M√âDICO-EST√âTICO", name: "Instrumental Quir√∫rgico", priceNew: 90000, priceReacondicionado: null, vidaUtilAnios: 10, maintenanceRate: 0.02 },
            { category: "CORE M√âDICO-EST√âTICO", name: "L√°mpara Quir√∫rgica LED", priceNew: 50000, priceReacondicionado: 40000, vidaUtilAnios: 7, maintenanceRate: 0.03 },
            { category: "DENTAL", name: "Sill√≥n Dental (A-dec 200)", priceNew: 75000, priceReacondicionado: 60000, vidaUtilAnios: 10, maintenanceRate: 0.04 },
            { category: "DENTAL", name: "Blanqueamiento LED (Philips Zoom)", priceNew: 60000, priceReacondicionado: 48000, vidaUtilAnios: 3, maintenanceRate: 0.05 },
            { category: "DENTAL", name: "Ultrasonido Dental", priceNew: 30000, priceReacondicionado: 24000, vidaUtilAnios: 5, maintenanceRate: 0.04 },
            { category: "CORPORAL & DEPILACI√ìN", name: "L√°ser de Diodo (Depilaci√≥n)", priceNew: 500000, priceReacondicionado: 350000, vidaUtilAnios: 5, maintenanceRate: 0.08 },
            { category: "CORPORAL & DEPILACI√ìN", name: "Cabina UVA (Soltron)", priceNew: 125000, priceReacondicionado: 100000, vidaUtilAnios: 7, maintenanceRate: 0.05 },
            { category: "CORPORAL & DEPILACI√ìN", name: "Sauna de Cabina (Amerec)", priceNew: 115000, priceReacondicionado: 75000, vidaUtilAnios: 10, maintenanceRate: 0.03 },
            { category: "GROOMING / ENTRADA", name: "Cauterizador Alta Frecuencia", priceNew: 25000, priceReacondicionado: 20000, vidaUtilAnios: 5, maintenanceRate: 0.03 },
            { category: "GROOMING / ENTRADA", name: "Ultrasonido Facial", priceNew: 30000, priceReacondicionado: 24000, vidaUtilAnios: 5, maintenanceRate: 0.04 },
            { category: "IMAGING MODULE", name: "C√°mara RGB (Basler/Sony)", priceNew: 23000, priceReacondicionado: 18000, vidaUtilAnios: 5, maintenanceRate: 0.03 },
            { category: "IMAGING MODULE", name: "C√°mara T√©rmica (FLIR)", priceNew: 18000, priceReacondicionado: 13000, vidaUtilAnios: 5, maintenanceRate: 0.03 },
            { category: "ACCESORIOS", name: "Otros y Accesorios Menores", priceNew: 75000, priceReacondicionado: null, vidaUtilAnios: 3, maintenanceRate: 0.01 }
        ]
    },
    opexCorporativo: {
        infrastructure: {
            cloudInfraMonthly: 15000,
            saasLicensesMonthly: 5000
        },
        G_A: {
            baseMonthlyCost: 100000, 
            costPerLocationTrigger: 3,
            costIncreasePerTrigger: 50000
        },
        techTeam_RnD: {
            baseMonthlyCost: 120000, 
            newHireTriggerLocations: 2,
            costPerNewHire: 80000
        }
    },
    capitalStructure: {
        fundingCascade: ["equityRounds", "ventureDebt", "commercialDebt"],
        equityRounds: [
            { round: "Seed", amount: 8000000, month: 0, equityDilution: 0 },
            { round: "Series A", amount: 30000000, month: 12, equityDilution: 0.40 }
        ],
        debtFacilities: [
            { label: "Venture Debt", availableFromMonth: 18, maxAmount: 50000000, interestRate: 0.16, termYears: 4, amountDrawn: 0 },
            { label: "Growth Debt", availableFromMonth: 30, maxAmount: 75000000, interestRate: 0.14, termYears: 5, amountDrawn: 0 }
        ]
    },
    capexTecnologico: {
        initialInvestment: {
            iaStackDevelopment: 2500000
        },
        recurringCapexAsRevenuePercentage: 0.03,
        vidaUtilAnios: 3
    },
    locationRampUp: {
        month0: 0.02, month1: 0.05, month2: 0.15, month3: 0.30, month4: 0.50, month5: 0.70, 
        month6: 0.80, month7: 0.90, month8: 0.95, steadyState: 1.00
    },
    dataFlywheel: {
        enabled: true,
        learningRate: 0.03,
        diagnosticAccuracy: { baseline: 0.85, currentLevel: 0.85, maxLevel: 0.95 },
        crossSellImprovement: { baseline: 0.25, monthlyGain: 0.02, maxLevel: 0.45 },
        churnReduction: { maxImprovement: 0.15, rampMonths: 18 }
    },
    marketingVigente: {
        enabled: true,
        strategicFocus: 0.5, 
        dynamicCACOptimization: { 
            learningPeriod: 6,
            cacReductionRate: 0.02,
            maxReduction: 0.15 
        }
    },
    productsRevenue: {
        enabled: true,
        launchMonth: 18, 
        strategicImportance: "high",
        avgSpendPerCustomerPerMonth: 150,
        cogsPercentage: 0.40
    }
};
let modelData = JSON.parse(JSON.stringify(baseModelData)); // Working copy
const scenarios = {
    pessimistic: {
        marketing: { sustainBudgetPerLocation: 15000 },
        realismLevers: { funnelConversionRate: 0.60 },
        customerArchetypes: { carlos: { churnRate: 0.30 }, eduardo: { churnRate: 0.45 }, mantenimiento: { churnRate: 0.55 } },
        capacity: { targetUtilization: 0.65 }
    },
    base: {},
    optimistic: {
        marketing: { sustainBudgetPerLocation: 30000 },
        marketingChannels: { eduardoFunnel: { wordOfMouthMultiplier: 1.45 } },
        realismLevers: { funnelConversionRate: 0.80 },
        customerArchetypes: { carlos: { churnRate: 0.18 }, eduardo: { churnRate: 0.30 }, mantenimiento: { churnRate: 0.35 } },
        capacity: { targetUtilization: 0.75 }
    }
};
// Injected controlsConfig for Beauty Tech
const controlsConfig = {
    growth_engine: [
        { id: 'scenario', label: 'Escenarios Estrat√©gicos', type: 'scenario', tooltip: 'Selecciona un preset de supuestos (Pesimista, Base, Optimista) que ajustar√° m√∫ltiples palancas a la vez para simular diferentes condiciones de mercado.' },
        { id: 'sustainBudgetPerLocation', label: 'Inversi√≥n Marketing Mensual', min: 15000, max: 35000, step: 1000, type: 'range', format: val => formatCurrency(val, true), tooltip: 'Presupuesto mensual de marketing por sucursal. Ajusta el ritmo de adquisici√≥n de clientes y el CAC.' },
        { 
            id: 'strategicFocus', 
            label: 'Foco Estrat√©gico Mkt', 
            min: 0, max: 1, step: 0.05, 
            type: 'range', 
            format: val => {
                const rentabilidad = (val * 100).toFixed(0);
                const adquisicion = 100 - rentabilidad;
                return `${adquisicion}% Adq. / ${rentabilidad}% Rent.`;
            }, 
            tooltip: 'Define la asignaci√≥n del presupuesto de marketing. 0% = Foco en Adquisici√≥n (Volumen, arquetipos de entrada), 100% = Foco en Rentabilidad (Clientes Premium, arquetipo Carlos).' 
        },
        { id: 'wordOfMouthMultiplierEduardo', label: 'Potencial Viral (Boca a Boca)', min: 1.05, max: 1.50, step: 0.01, type: 'range', format: val => val.toFixed(2) + 'x', tooltip: 'Multiplicador de crecimiento org√°nico. Cada cliente pagado trae consigo clientes adicionales por recomendaci√≥n.' },
    ],
    capital_strategy: [
        { id: 'seedCapital', label: 'Capital Seed', min: 8000000, max: 17000000, step: 500000, type: 'range', format: val => `$${(val/1000).toLocaleString()}K`, tooltip: 'Capital inicial para lanzar la primera cl√≠nica, desarrollar el MVP tecnol√≥gico y cubrir los gastos operativos iniciales.' },
        { id: 'seriesACapital', label: 'Capital Serie A', min: 10000000, max: 30000000, step: 1000000, type: 'range', format: val => `$${(val/1000).toLocaleString()}K`, tooltip: 'Capital de crecimiento para financiar la expansi√≥n nacional y la evoluci√≥n del stack tecnol√≥gico. Se levanta en el mes 12.' },
        { id: 'ventureDebtRate', label: 'Tasa Venture Debt', min: 0.12, max: 0.22, step: 0.005, type: 'range', format: val => (val * 100).toFixed(1) + '%', tooltip: 'Tasa de inter√©s para la l√≠nea de Venture Debt, disponible a partir del mes 18 como opci√≥n de financiamiento no dilutivo.' },
    ],
    operations: [
        { id: 'equipmentStrategy', label: 'Estrategia de Equipo', type: 'select', options: ['nuevo', 'reacondicionado'], tooltip: 'Elegir entre equipo nuevo (mayor CAPEX, mayor vida √∫til) o reacondicionado (menor CAPEX inicial).' },
        { id: 'clinicSizeM2', label: 'Tama√±o Cl√≠nica (m¬≤)', min: 150, max: 400, step: 10, type: 'number', format: val => `${val} m¬≤`, tooltip: 'Metros cuadrados para el c√°lculo del CAPEX de remodelaci√≥n.' },
        { id: 'remodelCostPerM2', label: 'Costo Remodelaci√≥n ($/m¬≤)', min: 12000, max: 25000, step: 500, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Costo de adecuaci√≥n por metro cuadrado.' },
    ],
    IA_Native_Controls: {
      OptiVigenteAI: {
        label: "OptiVigente AI (Eficiencia Operativa)",
        type: "toggle",
        default: true,
        description: "Aumenta las horas de servicio efectivas de la cl√≠nica optimizando agendas y recursos. Impacto directo en la capacidad de crecimiento."
      },
      MarketingVigenteAI: {
        label: "MarketingVigente AI (Optimizaci√≥n de CAC)",
        type: "toggle",
        default: true,
        description: "Reduce el Costo de Adquisici√≥n de Cliente (CAC) al optimizar la inversi√≥n en pauta digital de forma autom√°tica."
      },
      PersonaVigenteAI: {
        label: "PersonaVigente AI (Inteligencia de Cliente)",
        type: "toggle",
        default: true,
        description: "Habilita el cross-sell y upsell personalizado, aumentando el ingreso promedio por cliente."
      }
    },
    monetization: [
        { id: 'membershipPriceAccess', label: 'Precio Membres√≠a Access', min: 800, max: 2000, step: 100, type: 'range', format: val => formatCurrency(val, true), tooltip: 'Precio mensual de la membres√≠a de entrada para arquetipos Eduardo y Mantenimiento.' },
        { id: 'membershipAdoptionAccess', label: 'Adopci√≥n Membres√≠a Access', min: 0.20, max: 0.50, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Porcentaje de clientes elegibles que adoptan la membres√≠a Access.' },
        { id: 'membershipPriceElite', label: 'Precio Membres√≠a Elite', min: 2500, max: 5000, step: 100, type: 'range', format: val => formatCurrency(val, true), tooltip: 'Precio mensual de la membres√≠a premium para el arquetipo Carlos.' },
        { id: 'membershipAdoptionElite', label: 'Adopci√≥n Membres√≠a Elite', min: 0.10, max: 0.40, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Porcentaje de Carlos que adoptan la membres√≠a Elite.' },
        { id: 'dtcSpend', label: 'Gasto en Productos (DTC)/Cliente', min: 50, max: 400, step: 10, type: 'range', format: val => formatCurrency(val, true), tooltip: 'Gasto promedio mensual por cliente activo en productos de cuidado en casa.' },
        { id: 'bnplUplift', label: 'Uplift por BNPL en Cl√≠nica (Upsale)', min: 1.0, max: 1.5, step: 0.01, type: 'range', format: val => `+${((val - 1) * 100).toFixed(0)}%`, tooltip: 'Multiplicador de ingresos en servicios caros gracias a las facilidades de pago (BNPL) ofrecidas en la cl√≠nica.' },
        { id: 'specialistRevenueShare', label: 'Revenue Share Especialistas', min: 0.40, max: 0.60, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Porcentaje de los ingresos por servicios que se paga a los especialistas. Impacta directamente el margen bruto.' },
    ],
    customer_dynamics: [
        { id: 'realismFactor', label: 'Factor de Realismo General', min: 0.6, max: 1.0, step: 0.05, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Ajusta el optimismo del mercado. Afecta la probabilidad de que un cliente adopte un servicio por primera vez.' },
        { id: 'cohortMaturityMonths', label: 'Madurez de Cliente (Meses)', min: 6, max: 24, step: 1, type: 'range', format: val => `${val} meses`, tooltip: 'N√∫mero de meses para que una cohorte de clientes se considere "madura" y adopte comportamientos de mayor valor y consumo cl√≠nico.' },
        { id: 'adherenceUltra', label: 'Adherencia (Esenciales)', min: 0.8, max: 1.2, step: 0.05, type: 'range', format: val => val.toFixed(2) + 'x', tooltip: 'Multiplicador sobre la adherencia base para servicios de alta frecuencia y h√°bito, como cortes de pelo y barba. El pilar de la recurrencia.' },
        { id: 'adherenceHigh', label: 'Adherencia (Mantenimiento)', min: 0.8, max: 1.2, step: 0.05, type: 'range', format: val => val.toFixed(2) + 'x', tooltip: 'Multiplicador sobre la adherencia base para servicios de bienestar recurrentes, como limpiezas faciales y masajes. El motor de la rutina.' },
        { id: 'adherencePremium', label: 'Adherencia (Inversi√≥n)', min: 0.8, max: 1.2, step: 0.05, type: 'range', format: val => val.toFixed(2) + 'x', tooltip: 'Multiplicador sobre la adherencia base para tratamientos de alto impacto que requieren una decisi√≥n de inversi√≥n, como Botox o HIFU.' },
        { id: 'adherenceLuxury', label: 'Adherencia (Aspiracional)', min: 0.8, max: 1.2, step: 0.05, type: 'range', format: val => val.toFixed(2) + 'x', tooltip: 'Multiplicador sobre la adherencia base para servicios exclusivos o de lujo, como procedimientos avanzados o cirug√≠as.' },
    ],
    assumptions: [
        { id: 'treatmentRooms', label: 'Salas de Tratamiento / Sucursal', min: 3, max: 8, step: 1, type: 'range', format: val => `${val} salas`, tooltip: 'N√∫mero de salas de tratamiento por cl√≠nica. Define la capacidad de servicio y el CAPEX.' },
        { id: 'targetUtilization', label: 'Utilizaci√≥n Target', min: 0.60, max: 0.85, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Target de ocupaci√≥n de salas. Una decisi√≥n estrat√©gica clave que balancea ingresos y calidad del servicio.' },
        { id: 'funnelConversionRate', label: 'Tasa Conversi√≥n (Lead a Cliente)', min: 0.50, max: 0.90, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Porcentaje de clientes potenciales (leads) que efectivamente se convierten en clientes de pago.' },
        { id: 'churnRateCarlos', label: 'Churn Anual - Carlos', min: 0.15, max: 0.35, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Tasa de abandono anual para el arquetipo de mayor valor.' },
        { id: 'churnRateEduardo', label: 'Churn Anual - Eduardo', min: 0.25, max: 0.50, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Tasa de abandono anual para el arquetipo de volumen.' },
        { id: 'churnRateMantenimiento', label: 'Churn Anual - Mantenimiento', min: 0.30, max: 0.60, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Tasa de abandono anual para el arquetipo de mantenimiento.' },
        { id: 'churnRateTransaccional', label: 'Churn Anual - Transaccional', min: 0.50, max: 0.90, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: 'Tasa de abandono para el cliente m√°s vol√°til, clave para el modelo de conversi√≥n.' },
    ]
};
let financialResults = { pl: [], cf: [], bs: [], kpis: [], tirEquity: 0, detailedPL: [] };
const BALANCE_TOLERANCE = 1000;
// ===================================================================
// ===== PHASE 2: FINANCIAL CALCULATION ENGINE (THE HOW) ============
// ===================================================================
function formatCurrency(value, full = false) {
    if (value === null || value === undefined || isNaN(value)) return '$0';
    value = parseFloat(value);
    if (full) {
        return '$' + value.toLocaleString('es-MX', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
    }
    if (Math.abs(value) >= 1000000) {
        return '$' + (value / 1000000).toFixed(1) + 'M';
    } else if (Math.abs(value) >= 1000) {
        return '$' + (value / 1000).toFixed(1) + 'K';
    }
    return '$' + Math.round(value).toLocaleString();
}
/**
 * Churn din√°mico por antig√ºedad de cohorte
 */
function getDynamicChurn(archetype, cohortAgeMonths) {
    const baseChurn = modelData.customerArchetypes[archetype].churnRate;
    let ageMultiplier;
    if (cohortAgeMonths <= 3) {
        ageMultiplier = 2.5;    // 2.5x m√°s churn primeros 3 meses
    } else if (cohortAgeMonths <= 12) {
        ageMultiplier = 1.5;    // 1.5x churn hasta el a√±o
    } else {
        ageMultiplier = 0.7;    // 30% menos churn despu√©s del a√±o (lealtad)
    }
    return Math.min(baseChurn * ageMultiplier, 0.95); // Cap m√°ximo 95%
}
/**
 * üî•   V50.3 REPLACEMENT: Calculates the average service hours a new customer will consume using the adherence matrix.
 */
function getAvgHoursPerNewCustomer(modelData) {
    let totalHours = 0;
    let totalPercentage = 0;
    const { customerArchetypes, pricing, adherenceMatrix, customerBehavior } = modelData;
    const realismFactor = customerBehavior?.realismFactor || 1.0;
    for (const archetype in customerArchetypes) {
        if (archetype === 'transaccional') continue; // Exclude walk-ins from paid acquisition calc
        const archData = customerArchetypes[archetype];
        const journey = customerJourneyInitial[archetype]; // Use initial journey for new customers
        let hoursForArchetype = 0;
        for (const serviceName in journey) {
            const adoptionRate = journey[serviceName] * realismFactor;
            const service = pricing.services.find(s => s.name === serviceName);
            if (adoptionRate > 0 && service && service.repurchaseCycleMonths > 0) {
                const adherenceTier = service.adherenceTier || 'high'; // fallback
                const adherenceFactor = adherenceMatrix[archetype]?.[adherenceTier] || 0.75; // fallback
                const monthlyFrequency = (1 / service.repurchaseCycleMonths) * adherenceFactor;
                hoursForArchetype += adoptionRate * monthlyFrequency * service.avgDurationHours;
            }
        }
        totalHours += hoursForArchetype * archData.percentage;
        totalPercentage += archData.percentage;
    }
    
    return totalPercentage > 0 ? totalHours / totalPercentage : 0.5; // Return weighted average, or a default of 0.5 hours
}
/**
 * Module 1: Customer Growth and Revenue Build-Up Engine.
 * COHORT ENGINE: Re-architected to track monthly customer cohorts.
 */
function runMonthlySimulation(modelData, previousMonthState, month) {
    // --- I. SETUP AND LEVERS ---
    const { aiDefaults, customerArchetypes, marketing, marketingChannels, pricing, expansionPlan, capacity, locationRampUp, productsRevenue, customerBehavior } = modelData;
    const efficiencyUplift = toggleControls.OptiVigenteAI ? (aiDefaults?.efficiencyUplift ?? 1.0) : 1.0;
    const CACReduction = toggleControls.MarketingVigenteAI ? (aiDefaults?.CACReduction ?? 0.0) : 0.0;
    const aiPersonalizationUplift = toggleControls.PersonaVigenteAI ? (aiDefaults?.aiPersonalizationUplift ?? 0.0) : 0.0;
    const crossSellBoost = toggleControls.PersonaVigenteAI ? (aiDefaults?.crossSellBoost ?? 0.0) : 0.0;
    const realismFactor = customerBehavior?.realismFactor || 1.0;
    const premiumDiscount = pricing?.premiumServiceDiscount || 0.0;
    const cohortMaturityMonths = customerBehavior?.cohortMaturityMonths || 12;

    const nextMonthCohorts = {};
    
    // --- II. CUSTOMER RETENTION & CONVERSION (COHORT-BASED) ---
    for (const cohortMonth in previousMonthState.customerCohorts) {
        const cohort = previousMonthState.customerCohorts[cohortMonth];
        const survivingCohort = {};
        let cohortHasSurvivors = false;
        for (const archetype in cohort) {
            const previousActive = cohort[archetype];
            if (previousActive <= 0) continue;
            const cohortAgeMonths = month - parseInt(cohortMonth);
            const dynamicAnnualChurn = getDynamicChurn(archetype, cohortAgeMonths);
            const monthlyChurnRate = 1 - Math.pow(1 - dynamicAnnualChurn, 1/12);
            const membershipTier = (archetype === 'carlos') ? 'elite' : 'access';
            const membership = pricing.membership[membershipTier];
            let adoptionRate = 0, churnReduction = 0;
            if (membership && membership.targetArchetype.includes(archetype)) {
                adoptionRate = membership.adoptionRate;
                churnReduction = membership.behaviorChanges.churnReduction;
            }
            
            const members = previousActive * adoptionRate;
            const nonMembers = previousActive - members;
            const retainedMembers = members * (1 - (monthlyChurnRate * (1 - churnReduction)));
            const retainedNonMembers = nonMembers * (1 - monthlyChurnRate);
            
            survivingCohort[archetype] = retainedMembers + retainedNonMembers;
            if (survivingCohort[archetype] > 0.1) {
                 cohortHasSurvivors = true;
            }
        }
        const cohortAgeMonths = month - parseInt(cohortMonth);
        if (cohortHasSurvivors && cohortAgeMonths <= 36) {
             nextMonthCohorts[cohortMonth] = survivingCohort;
        }
    }
    for (const cohortMonth in nextMonthCohorts) {
        const cohort = nextMonthCohorts[cohortMonth];
        if (cohort.transaccional > 0) {
            const conversionConfig = customerArchetypes.transaccional.conversionTo;
            const convertingCustomers = cohort.transaccional * (conversionConfig?.rate || 0);
            if (convertingCustomers > 0) {
                cohort.transaccional -= convertingCustomers;
                cohort.mantenimiento = (cohort.mantenimiento || 0) + convertingCustomers;
            }
        }
    }
    // --- III. EXPANSION & CAPACITY CALCULATION ---
    let activeSucursales = previousMonthState.activeSucursales;
    let newLocationsThisMonth = 0;
    const activeLocations = [...previousMonthState.activeLocations];
    activeLocations.forEach(loc => { loc.monthsSinceOpening++; });
    const expansionEvent = expansionPlan.expansionSchedule.find(e => e.month === month);
    if (expansionEvent) {
         activeSucursales++;
         newLocationsThisMonth++;
         activeLocations.push({ city: expansionEvent.city, monthsSinceOpening: 0, openingMonth: month });
    }
    const baseCapacityPerLocation = capacity.treatmentRooms * capacity.dailyOperatingHours * capacity.daysOpenPerMonth;
    const totalCapacityAllLocations = baseCapacityPerLocation * activeSucursales;
    const totalAvailableHours = totalCapacityAllLocations * capacity.targetUtilization * efficiencyUplift;
    
    // --- IV. DYNAMIC CUSTOMER ACQUISITION (V49 LOGIC) ---
    let hoursConsumedByExisting = 0;
    for (const cohortMonth in nextMonthCohorts) {
        const cohortAgeMonths = month - parseInt(cohortMonth);
        const journeyToUse = cohortAgeMonths < cohortMaturityMonths ? customerJourneyInitial : customerJourneyMature;
        for (const archetype in nextMonthCohorts[cohortMonth]) {
            const customersInCohort = nextMonthCohorts[cohortMonth][archetype];
            const journey = journeyToUse[archetype];
            for(const serviceName in journey) {
                const service = pricing.services.find(s => s.name === serviceName);
                if(service && service.repurchaseCycleMonths > 0) {
                    const adherenceTier = service.adherenceTier || 'high';
                    const adherenceFactor = (modelData.adherenceMatrix[archetype]?.[adherenceTier] || 0.75) * (modelData.customerBehavior.adherenceMultipliers[adherenceTier] || 1.0);
                    const monthlyFrequency = (1 / service.repurchaseCycleMonths) * adherenceFactor;
                    hoursConsumedByExisting += customersInCohort * (journey[serviceName] * realismFactor) * monthlyFrequency * service.avgDurationHours;
                }
            }
        }
    }
    
    const hoursAvailableForGrowth = Math.max(0, totalAvailableHours - hoursConsumedByExisting);
    const avgHoursPerNewCustomer = getAvgHoursPerNewCustomer(modelData);
    const maxNewCustomersFromCapacity = avgHoursPerNewCustomer > 0 ? Math.floor(hoursAvailableForGrowth / avgHoursPerNewCustomer) : 0;
    let totalMarketingBudget;
    const launchConfig = marketing.launchStrategy;
    if (month <= launchConfig.durationMonths) {
        totalMarketingBudget = launchConfig.seedFundingAllocation / launchConfig.durationMonths;
    } else if (expansionEvent) {
        const isNewPlaza = !previousMonthState.launchedMarkets.has(expansionEvent.city);
        totalMarketingBudget = isNewPlaza ? (launchConfig.plazaLaunchBudget / launchConfig.durationMonths) : (launchConfig.sucursalLaunchBudget / launchConfig.durationMonths);
    } else {
        totalMarketingBudget = marketing.sustainBudgetPerLocation * activeSucursales;
    }
    
    const budgetAllocations = calculateIntelligentBudgetAllocation(modelData, month, totalMarketingBudget);
    const desiredNewCustomers = {};
    let totalDesiredNewCustomers = 0;
    
    let effectiveConversionRate = modelData.realismLevers.funnelConversionRate;
    if (modelData.pricing.bnpl.marketingEnabled) {
        effectiveConversionRate *= 1.15;
    }
    for (const archetype in customerArchetypes) {
        if (archetype === 'transaccional') continue;
        const funnel = marketingChannels[`${archetype}Funnel`];
        if (!funnel) continue;
        const budgetForArchetype = budgetAllocations[archetype] || 0;
        const effectiveCAC = funnel.cac * (1 - CACReduction);
        const paidCustomers = effectiveCAC > 0 ? Math.floor(budgetForArchetype / effectiveCAC) : 0;
        const organicCustomers = Math.floor(paidCustomers * (funnel.wordOfMouthMultiplier - 1));
        const totalAcquired = (paidCustomers + organicCustomers) * effectiveConversionRate;
        desiredNewCustomers[archetype] = { total: totalAcquired, paid: paidCustomers * effectiveConversionRate, organic: organicCustomers * effectiveConversionRate };
        totalDesiredNewCustomers += totalAcquired;
    }
    const newCustomers = {};
    const walkIns = (marketing.walkInsPerLocationPerMonth || 0) * activeSucursales;
    newCustomers.transaccional = { total: walkIns, paid: 0, organic: walkIns };
    if (totalDesiredNewCustomers > maxNewCustomersFromCapacity) {
        log(`  üìà   M${month}: Crecimiento limitado por capacidad. Deseados: ${Math.round(totalDesiredNewCustomers)}, Permitidos: ${maxNewCustomersFromCapacity}`);
        const scaleFactor = totalDesiredNewCustomers > 0 ? maxNewCustomersFromCapacity / totalDesiredNewCustomers : 0;
        for (const archetype in desiredNewCustomers) {
            newCustomers[archetype] = {
                total: desiredNewCustomers[archetype].total * scaleFactor,
                paid: desiredNewCustomers[archetype].paid * scaleFactor,
                organic: desiredNewCustomers[archetype].organic * scaleFactor
            };
        }
    } else {
        for (const archetype in desiredNewCustomers) {
            newCustomers[archetype] = desiredNewCustomers[archetype];
        }
    }
    const newCohortData = {};
    for(const archetype in newCustomers){
        newCohortData[archetype] = newCustomers[archetype].total;
    }
    nextMonthCohorts[month] = newCohortData;
    
    // --- V. REVENUE ENGINE ---
    let serviceRevenue = 0;
    let totalSessionHours = 0;
    let totalDiscounts = 0;
    const activeSucursalesForRevenue = activeSucursales > 0 ? activeSucursales : 1;
    const activeCustomers = {};
    let totalActiveCustomers = 0;
    const tierBreakdown = { premium: 0, surgery: 0, mid: 0, basic: 0 };
    const serviceBreakdown = {};
    pricing.services.forEach(s => serviceBreakdown[s.name] = 0);
    for (const cohortMonth in nextMonthCohorts) {
        for (const archetype in nextMonthCohorts[cohortMonth]) {
            activeCustomers[archetype] = (activeCustomers[archetype] || 0) + nextMonthCohorts[cohortMonth][archetype];
        }
    }
    for (const archetype in activeCustomers) {
        totalActiveCustomers += activeCustomers[archetype];
    }
    
    let totalServiceRevenueFromLocations = 0;
    activeLocations.forEach(loc => {
        const rampUpKey = `month${loc.monthsSinceOpening}`;
        const rampUpFactor = locationRampUp[rampUpKey] || locationRampUp.steadyState;
        
        for (const service of pricing.services) {
            let customersUsingThisService = 0;
            // V50.9: Iterate through cohorts to apply correct journey
            for (const cohortMonth in nextMonthCohorts) {
                const cohortAgeMonths = month - parseInt(cohortMonth);
                const journeyToUse = cohortAgeMonths < cohortMaturityMonths ? customerJourneyInitial : customerJourneyMature;

                for (const archetype in nextMonthCohorts[cohortMonth]) {
                    const customersInCohort = nextMonthCohorts[cohortMonth][archetype];
                    let adoptionRateForService = (journeyToUse[archetype]?.[service.name] || 0) * realismFactor;
                    customersUsingThisService += (customersInCohort / activeSucursalesForRevenue) * adoptionRateForService;
                }
            }

            if (customersUsingThisService > 0 && service.repurchaseCycleMonths > 0) {
                let weightedAdherence = 0;
                let totalWeight = 0;
                for (const archetype in activeCustomers) {
                    const customerCount = activeCustomers[archetype] || 0;
                    const adoptionRateForService = (customerJourneyInitial[archetype]?.[service.name] || 0) * realismFactor; // Use initial for simplicity here
                    if (customerCount > 0 && adoptionRateForService > 0) {
                        const adherenceTier = service.adherenceTier || 'high';
                        const adherenceFactor = (modelData.adherenceMatrix[archetype]?.[adherenceTier] || 0.75) * (modelData.customerBehavior.adherenceMultipliers[adherenceTier] || 1.0);
                        const weight = customerCount * adoptionRateForService;
                        weightedAdherence += adherenceFactor * weight;
                        totalWeight += weight;
                    }
                }
                const finalAdherence = totalWeight > 0 ? weightedAdherence / totalWeight : 0.75;
                const monthlyFrequency = (1 / service.repurchaseCycleMonths) * finalAdherence;
                
                let servicePrice = service.defaultPrice;
                if (['Botox', 'HIFU', 'Fillers', 'RF Microneedling'].includes(service.name)) {
                    servicePrice *= (1 - premiumDiscount);
                }
                if (pricing.bnpl.enabled && servicePrice > pricing.bnpl.minPriceThreshold) {
                    servicePrice *= pricing.bnpl.revenueUpliftMultiplier;
                }
                for (const archetype in activeCustomers) {
                    const membershipTier = (archetype === 'carlos') ? 'elite' : 'access';
                    const membership = pricing.membership[membershipTier];
                    if (membership && membership.targetArchetype.includes(archetype)) {
                         const adoptionRateForService = (customerJourneyInitial[archetype]?.[service.name] || 0) * realismFactor;
                         const membersConsuming = (activeCustomers[archetype] / activeSucursalesForRevenue) * adoptionRateForService * membership.adoptionRate;
                         if (membersConsuming > 0) {
                             const discountAmount = servicePrice * membership.discountRate;
                             totalDiscounts += (membersConsuming * monthlyFrequency * discountAmount) * rampUpFactor;
                         }
                    }
                }
                const currentServiceRevenue = (customersUsingThisService * monthlyFrequency * servicePrice) * rampUpFactor;
                totalServiceRevenueFromLocations += currentServiceRevenue;
                totalSessionHours += (customersUsingThisService * monthlyFrequency * service.avgDurationHours) * rampUpFactor;
                
                if(tierBreakdown[service.tier] !== undefined) {
                    tierBreakdown[service.tier] += currentServiceRevenue;
                }
                serviceBreakdown[service.name] += currentServiceRevenue;
            }
        }
    });
    serviceRevenue = totalServiceRevenueFromLocations * (1 + aiPersonalizationUplift + crossSellBoost);
    
    let membershipRevenue = 0;
    for (const archetype in activeCustomers) {
        const customers = activeCustomers[archetype];
        const membershipTier = (archetype === 'carlos') ? 'elite' : 'access';
        const membership = pricing.membership[membershipTier];
        if (membership && membership.targetArchetype.includes(archetype)) {
            const customersPerLocation = customers / activeSucursalesForRevenue;
            const membershipCustomersPerLocation = customersPerLocation * membership.adoptionRate;
            let totalMembershipRevenue = 0;
            activeLocations.forEach(loc => {
                const rampUpKey = `month${loc.monthsSinceOpening}`;
                const rampUpFactor = locationRampUp[rampUpKey] || locationRampUp.steadyState;
                totalMembershipRevenue += (membershipCustomersPerLocation * membership.price) * rampUpFactor;
            });
            membershipRevenue += totalMembershipRevenue;
        }
    }
    const maxMembershipRevenue = (serviceRevenue - totalDiscounts) * 0.4;
    if (membershipRevenue > maxMembershipRevenue) {
        log(`  ‚ö†Ô∏è   Membres√≠as limitadas: ${formatCurrency(membershipRevenue)} ‚Üí ${formatCurrency(maxMembershipRevenue)}`);
        membershipRevenue = maxMembershipRevenue;
    }
    
    let productRevenue = 0;
    if (productsRevenue.enabled && month >= productsRevenue.launchMonth) {
        productRevenue = totalActiveCustomers * productsRevenue.avgSpendPerCustomerPerMonth;
    }
    
    let totalGrossRevenue = serviceRevenue + membershipRevenue + productRevenue;
    log(`  üí∞   Revenue breakdown M${month}: Servicios=${formatCurrency(serviceRevenue)} | Membres√≠as=${formatCurrency(membershipRevenue)} | Descuentos=${formatCurrency(totalDiscounts)}`);
    let capacityUtilization = totalAvailableHours > 0 ? totalSessionHours / totalAvailableHours : 0;
    
    return {
        month, activeCustomers, totalActiveCustomers, newCustomers, activeSucursales, activeLocations,
        customerCohorts: nextMonthCohorts,
        launchedMarkets: new Set(activeLocations.map(l => l.city)), newLocationsThisMonth, marketingBudget: totalMarketingBudget,
        revenue: { 
            total: totalGrossRevenue - totalDiscounts, gross: totalGrossRevenue, discounts: totalDiscounts, 
            services: serviceRevenue, memberships: membershipRevenue, products: productRevenue, 
            crossSell: serviceRevenue * (aiPersonalizationUplift + crossSellBoost),
            byTier: tierBreakdown, byService: serviceBreakdown
        },
        operations: { totalSessionHours, capacityUtilization }
    };
}
/**
 * Allocates budget based on the strategic focus slider.
 */
function calculateIntelligentBudgetAllocation(modelData, month, totalBudget) {
    const strategicFocus = modelData.marketingVigente.strategicFocus; 
    let allocations = { carlos: 0, eduardo: 0, mantenimiento: 0, transaccional: 0 };
    const profitabilityBudget = totalBudget * strategicFocus;
    const acquisitionBudget = totalBudget * (1 - strategicFocus);
    allocations.carlos = profitabilityBudget;
    const eduardoWeight = modelData.customerArchetypes.eduardo.percentage;
    const mantenimientoWeight = modelData.customerArchetypes.mantenimiento.percentage;
    const totalAcquisitionWeight = eduardoWeight + mantenimientoWeight;
    if (totalAcquisitionWeight > 0) {
        allocations.eduardo = acquisitionBudget * (eduardoWeight / totalAcquisitionWeight);
        allocations.mantenimiento = acquisitionBudget * (mantenimientoWeight / totalAcquisitionWeight);
    } else {
        allocations.eduardo = acquisitionBudget / 2;
        allocations.mantenimiento = acquisitionBudget / 2;
    }
    return allocations;
}
/**
 * Module 2: Cost, Expense, and Investment Engine (OPEX & CAPEX).
 */
function calculateMonthlyCosts(modelData, currentState, previousYearRevenue, previousMonthState) { 
    const { month, operations, activeSucursales, newLocationsThisMonth, totalActiveCustomers } = currentState;
    const { opexSucursal, opexCorporativo, capexSucursal, capexTecnologico } = modelData;
    const operariosNeeded = Math.ceil(activeSucursales * modelData.capacity.treatmentRooms * opexSucursal.staffRatios.operariosPerRoom);
    const medicosNeeded = Math.ceil(operations.totalSessionHours * opexSucursal.staffRatios.medicoPerSession);
    const conciergesNeeded = Math.ceil(totalActiveCustomers * opexSucursal.staffRatios.conciergePerClient);
    const costLaborOperarios = operariosNeeded * opexSucursal.labor.operario.salary;
    const costLaborMedicos = medicosNeeded * opexSucursal.labor.medicoEsteticista.minMonthlyGuarantee;
    const costLaborConcierge = conciergesNeeded * opexSucursal.labor.concierge.salary;
    const totalCostLaborBase = costLaborOperarios + costLaborMedicos + costLaborConcierge;
    let energyVariableCost = 0;
    
    const energyFixedCost = opexSucursal.energy.fixedMonthlyKwh * opexSucursal.energy.costPerKwh * activeSucursales;
    const totalCostEnergy = energyFixedCost + energyVariableCost;
    
    const costRenta = opexSucursal.rentaMensual * activeSucursales;
    const costAdminLocal = opexSucursal.adminLocalMonthly * activeSucursales;
    
    const opexSucursalTotal = costRenta + costAdminLocal;
    
    const opexGA = opexCorporativo.G_A.baseMonthlyCost + (Math.floor(activeSucursales / opexCorporativo.G_A.costPerLocationTrigger) * opexCorporativo.G_A.costIncreasePerTrigger);
    const numNewHires = Math.floor(activeSucursales / opexCorporativo.techTeam_RnD.newHireTriggerLocations);
    const opexTechTeam = opexCorporativo.techTeam_RnD.baseMonthlyCost + (numNewHires * opexCorporativo.techTeam_RnD.costPerNewHire);
    const opexInfra = opexCorporativo.infrastructure.cloudInfraMonthly + opexCorporativo.infrastructure.saasLicensesMonthly;
    const totalOpexCorporativo = opexGA + opexTechTeam + opexInfra;
    // --- DYNAMIC CAPEX CALCULATION ---
    let capexPhysical = 0;
    if (newLocationsThisMonth > 0) {
        const remodelCost = capexSucursal.remodelCostPerM2 * capexSucursal.clinicSizeM2;
        const equipmentCost = capexSucursal.equipmentList.reduce((sum, item) => {
            const price = capexSucursal.equipmentStrategy === 'reacondicionado' ? (item.priceReacondicionado || item.priceNew) : item.priceNew;
            return sum + price;
        }, 0);
        capexPhysical += (remodelCost + equipmentCost) * newLocationsThisMonth;
    }
    let capexTech = 0;
    if (month === 13) { 
        capexTech += capexTecnologico?.initialInvestment?.iaStackDevelopment || 0;
    }
    if (month > 12 && (month - 1) % 12 === 0) {
        const recurringTechCapex = previousYearRevenue * (capexTecnologico?.recurringCapexAsRevenuePercentage || 0.03);
        capexTech += recurringTechCapex;
    }
    
    // --- Depreciation Calculation ---
    const totalPhysicalAssets = (previousMonthState.balanceSheet.fixedAssets || 0) + capexPhysical;
    const totalTechAssets = (previousMonthState.balanceSheet.techAssets || 0) + capexTech;
    
    const validEquipment = capexSucursal.equipmentList.filter(eq => eq && typeof eq.vidaUtilAnios === 'number');
    const vidaUtilSum = validEquipment.reduce((sum, eq) => sum + eq.vidaUtilAnios, 0);
    const avgVidaUtilEquipos = validEquipment.length > 0 ? vidaUtilSum / validEquipment.length : 5; 
    const depreciationPhysical = avgVidaUtilEquipos > 0 ? totalPhysicalAssets / (avgVidaUtilEquipos * 12) : 0;
    const depreciationTech = (capexTecnologico?.vidaUtilAnios || 3) > 0 ? totalTechAssets / ((capexTecnologico?.vidaUtilAnios || 3) * 12) : 0;
    const depreciacionMensual = depreciationPhysical + depreciationTech;
    
    return {
        cogs: {
            energy: totalCostEnergy
        },
        opex: { 
            personnel: totalCostLaborBase,
            sucursal: opexSucursalTotal,
            corporate: totalOpexCorporativo,
            techTeam: opexTechTeam,
            ga: opexGA,
            marketing: currentState.marketingBudget,
            total: totalCostLaborBase + opexSucursalTotal + totalOpexCorporativo + currentState.marketingBudget
        },
        capex: { 
            total: capexPhysical + capexTech,
            physical: capexPhysical,
            tech: capexTech
        },
        depreciation: { 
            total: depreciacionMensual,
            physical: depreciationPhysical,
            tech: depreciationTech
        },
        currentState: currentState
    };
}
/**
 * Module 3: Financial Statement Assembler and Capital Logic
 */
function assembleFinancialStatements(modelData, monthlyRevenue, monthlyCosts, previousMonthState, month) {
    let suppliesCost = 0;
    let medicalServicesRevenue = 0;
    let productCogs = 0;
    const currentState = { ...monthlyRevenue, ...monthlyCosts.currentState };
    
    const pnl = {};
    pnl.revenue = (monthlyRevenue && monthlyRevenue.revenue) ? monthlyRevenue.revenue.total : 0;
    pnl.grossRevenue = (monthlyRevenue && monthlyRevenue.revenue) ? monthlyRevenue.revenue.gross : 0;
    pnl.discounts = (monthlyRevenue && monthlyRevenue.revenue) ? monthlyRevenue.revenue.discounts : 0;
    pnl.marketingSpend = monthlyRevenue.marketingBudget;
    
    const detailedPL = {
        revenue: { 
            total: pnl.revenue, 
            gross: pnl.grossRevenue,
            discounts: pnl.discounts,
            services: monthlyRevenue.revenue.services, 
            products: monthlyRevenue.revenue.products, 
            memberships: monthlyRevenue.revenue.memberships, 
            crossSell: monthlyRevenue.revenue.crossSell,
            byTier: monthlyRevenue.revenue.byTier,
            byService: monthlyRevenue.revenue.byService
        },
        cogs: { 
            total: 0, 
            supplies: 0, 
            products: 0,
            energy: monthlyCosts.cogs.energy, 
            byCategory: {} 
        },
        opex: {
             total: monthlyCosts.opex.total,
             personnel: {
                 total: monthlyCosts.opex.personnel,
                 fixed: 0,
                 variable: 0
             },
             sucursal: monthlyCosts.opex.sucursal,
             corporate: monthlyCosts.opex.corporate,
             techTeam: monthlyCosts.opex.techTeam,
             ga: monthlyCosts.opex.ga,
             marketing: monthlyCosts.opex.marketing
        }
    };
    if (currentState.operations && currentState.activeCustomers) {
        // Calculate Supplies and Revenue Share from the granular service engine
        for (const service of modelData.pricing.services) {
            let customersUsingThisService = 0;
            for (const archetype in currentState.activeCustomers) {
                const adoptionRate = (customerJourneyInitial[archetype]?.[service.name] || 0) * (modelData.customerBehavior?.realismFactor || 1.0);
                customersUsingThisService += currentState.activeCustomers[archetype] * adoptionRate;
            }
            if (customersUsingThisService > 0 && service.repurchaseCycleMonths > 0) {
                let weightedAdherence = 0;
                let totalWeight = 0;
                for (const archetype in currentState.activeCustomers) {
                    const customerCount = currentState.activeCustomers[archetype] || 0;
                    const adoptionRate = (customerJourneyInitial[archetype]?.[service.name] || 0) * (modelData.customerBehavior?.realismFactor || 1.0);
                    if (customerCount > 0 && adoptionRate > 0) {
                        const adherenceTier = service.adherenceTier || 'high';
                        const adherenceFactor = (modelData.adherenceMatrix[archetype]?.[adherenceTier] || 0.75) * (modelData.customerBehavior.adherenceMultipliers[adherenceTier] || 1.0);
                        const weight = customerCount * adoptionRate;
                        weightedAdherence += adherenceFactor * weight;
                        totalWeight += weight;
                    }
                }
                const finalAdherence = totalWeight > 0 ? weightedAdherence / totalWeight : 0.75;
                const monthlyFrequency = (1 / service.repurchaseCycleMonths) * finalAdherence;
                const totalSessions = customersUsingThisService * monthlyFrequency;
                
                suppliesCost += totalSessions * service.suppliesCost;
                
                if (service.revenueShare) {
                    let servicePrice = service.defaultPrice;
                    if (['Botox', 'HIFU', 'Fillers', 'RF Microneedling'].includes(service.name)) {
                        servicePrice *= (1 - (modelData.pricing?.premiumServiceDiscount || 0.0));
                    }
                    const serviceRevenue = totalSessions * servicePrice;
                    const maxRevenueShare = serviceRevenue * 0.5; // 50% m√°ximo por servicio
                    const calculatedShare = serviceRevenue * service.revenueShare;
                    const finalShare = Math.min(calculatedShare, maxRevenueShare);
                    medicalServicesRevenue += finalShare;
                    
                    if (calculatedShare > maxRevenueShare) {
                        log(`  ‚ö†Ô∏è   Revenue share limitado en ${service.name}: ${formatCurrency(calculatedShare)} ‚Üí ${formatCurrency(finalShare)}`);
                    }
                }
            }
        }
        
        if (modelData.productsRevenue.enabled && month >= modelData.productsRevenue.launchMonth) {
            productCogs = detailedPL.revenue.products * modelData.productsRevenue.cogsPercentage;
        }
    }
    detailedPL.cogs.supplies = suppliesCost;
    detailedPL.cogs.products = productCogs;
    detailedPL.cogs.total = suppliesCost + productCogs + detailedPL.cogs.energy;
    pnl.cogs = detailedPL.cogs.total;
    
    const maxMedicalRevenue = monthlyCosts.opex.personnel * 0.6;
    if (medicalServicesRevenue > maxMedicalRevenue) {
        log(`  ‚ö†Ô∏è   Revenue share excede l√≠mite personal: ${formatCurrency(medicalServicesRevenue)} ‚Üí ${formatCurrency(maxMedicalRevenue)}`);
        medicalServicesRevenue = maxMedicalRevenue;
    }
    detailedPL.opex.personnel.variable = medicalServicesRevenue;
    detailedPL.opex.personnel.fixed = Math.max(0, monthlyCosts.opex.personnel - medicalServicesRevenue);
    if (detailedPL.opex.personnel.fixed < 0) {
        log(`  üö®   CRITICAL: Salarios fijos negativos detectados y corregidos`);
        detailedPL.opex.personnel.fixed = monthlyCosts.opex.personnel * 0.4;
        detailedPL.opex.personnel.variable = monthlyCosts.opex.personnel * 0.6;
    }
    
    log(`  üë•   Personal M${month}: Fijo=${formatCurrency(detailedPL.opex.personnel.fixed)} | Variable=${formatCurrency(detailedPL.opex.personnel.variable)} | Total=${formatCurrency(monthlyCosts.opex.personnel)}`);
    pnl.grossProfit = pnl.revenue - pnl.cogs;
    pnl.opex = monthlyCosts.opex.total + medicalServicesRevenue;
    pnl.ebitda = pnl.grossProfit - pnl.opex;
    pnl.depreciation = monthlyCosts.depreciation.total;
    pnl.ebit = pnl.ebitda - pnl.depreciation;
    
    const prevDebtTotal = (previousMonthState.balanceSheet?.debt?.total) || 0;
    pnl.interestExpense = prevDebtTotal * (modelData.capitalStructure.debtFacilities[0].interestRate / 12);
    
    pnl.ebt = pnl.ebit - pnl.interestExpense;
    pnl.taxes = pnl.ebt > 0 ? pnl.ebt * modelData.taxSettings.isrMexico : 0;
    pnl.netIncome = pnl.ebt - pnl.taxes;
    
    const cashFlow = {};
    cashFlow.fromOperations = pnl.netIncome + pnl.depreciation;
    cashFlow.fromInvesting = -monthlyCosts.capex.total;
    
    let openingCash = (previousMonthState.balanceSheet?.cash) || 0;
    
    let fundsRaised = { equity: 0, debt: 0, from: '' };
    
    const availableRound = modelData.capitalStructure.equityRounds.find(r => r.month === month);
    if (availableRound) {
        fundsRaised.equity += availableRound.amount;
        fundsRaised.from += 'Equity ';
    }
    
    let debtDrawnThisMonth = 0;
    const cashAfterOpsAndEquity = openingCash + cashFlow.fromOperations + fundsRaised.equity;
    const cashNeededForCapex = monthlyCosts.capex.total;
    const cashShortfall = cashNeededForCapex - cashAfterOpsAndEquity;
    
    if (cashShortfall > 0) {
        for (const facility of modelData.capitalStructure.debtFacilities) {
            if (month >= facility.availableFromMonth) {
                const availableToDraw = facility.maxAmount - facility.amountDrawn;
                const drawAmount = Math.min(cashShortfall - debtDrawnThisMonth, availableToDraw);
                if (drawAmount > 0) {
                    facility.amountDrawn += drawAmount;
                    debtDrawnThisMonth += drawAmount;
                    fundsRaised.from += `${facility.label} `;
                }
            }
        }
    }
    fundsRaised.debt = debtDrawnThisMonth;
    cashFlow.fromFinancing = fundsRaised.equity + fundsRaised.debt;
    const finalNetCashFlow = cashFlow.fromOperations + cashFlow.fromInvesting + cashFlow.fromFinancing;
    const balanceSheet = {};
    balanceSheet.cash = openingCash + finalNetCashFlow;
    
    const prevFixedAssets = previousMonthState.balanceSheet.fixedAssets || 0;
    const prevTechAssets = previousMonthState.balanceSheet.techAssets || 0;
    balanceSheet.fixedAssets = prevFixedAssets - monthlyCosts.depreciation.physical + monthlyCosts.capex.physical;
    balanceSheet.techAssets = prevTechAssets - monthlyCosts.depreciation.tech + monthlyCosts.capex.tech;
    balanceSheet.totalAssets = balanceSheet.cash + balanceSheet.fixedAssets + balanceSheet.techAssets;
    balanceSheet.debt = { total: prevDebtTotal + fundsRaised.debt };
    balanceSheet.equity = (previousMonthState.balanceSheet?.equity || 0) + pnl.netIncome + fundsRaised.equity;
    balanceSheet.totalLiabilitiesAndEquity = balanceSheet.debt.total + balanceSheet.equity;
    const balanceDifference = balanceSheet.totalAssets - balanceSheet.totalLiabilitiesAndEquity;
    if (Math.abs(balanceDifference) > 1000) {
        balanceSheet.equity += balanceDifference;
        balanceSheet.totalLiabilitiesAndEquity = balanceSheet.debt.total + balanceSheet.equity;
    }
    return {
        month: month, pnl, cashFlow, balanceSheet, fundsRaised, detailedPL,
        operations: currentState.operations,
        activeSucursales: currentState.activeSucursales,
        totalActiveCustomers: currentState.totalActiveCustomers,
        newCustomers: currentState.newCustomers,
        customerCohorts: currentState.customerCohorts,
        newCustomersPaid: Object.fromEntries(
            Object.entries(currentState.newCustomers).map(([arch, data]) => [
                arch, 
                typeof data === 'object' ? data.paid : 0
            ])
        ),
        activeLocations: currentState.activeLocations,
        launchedMarkets: currentState.launchedMarkets,
        kpis: {
            ltv_cac_ratio: 0,
            ltvCacBreakdown: ''
        }
    };
}
/**
 * Main orchestrator of the financial model.
 */
function calculateFinancials() {
    log('   üöÄ    ModelCalc v51.0 (Strategic Cockpit) STARTING');
    try {
        financialResults = { pl: [], cf: [], bs: [], kpis: [], tirEquity: 0, detailedPL: [], breakEvenMonth: null };
        modelData.capitalStructure.debtFacilities.forEach(f => f.amountDrawn = 0);
        
        let previousMonthState = {
            month: 0,
            customerCohorts: {}, 
            activeLocations: [],
            launchedMarkets: new Set(),
            activeSucursales: 0, 
            balanceSheet: {
                cash: 0, fixedAssets: 0, techAssets: 0, totalAssets: 0,
                debt: { total: 0 }, equity: 0, totalLiabilitiesAndEquity: 0
            }
        };
        const seedRound = modelData.capitalStructure.equityRounds.find(r => r.month === 0);
        if (seedRound) {
            previousMonthState.balanceSheet.cash = seedRound.amount;
            previousMonthState.balanceSheet.equity = seedRound.amount;
            previousMonthState.balanceSheet.totalAssets = seedRound.amount;
            previousMonthState.balanceSheet.totalLiabilitiesAndEquity = seedRound.amount;
        }
        
        let monthlyResults = [];
        let previousYearRevenue = 0;
        let cumulativeCFO = 0;
        let breakEvenFound = false;
        for (let month = 1; month <= modelData.general.projectionTimeline.duration; month++) {
            if ((month - 1) % 12 === 0 && month > 1) {
                const lastYearMonths = monthlyResults.slice(month - 13, month - 1);
                previousYearRevenue = lastYearMonths.reduce((sum, m) => sum + m.pnl.revenue, 0);
            }
            const revenueState = runMonthlySimulation(modelData, previousMonthState, month);
            const costState = calculateMonthlyCosts(modelData, revenueState, previousYearRevenue, previousMonthState); 
            const fullState = assembleFinancialStatements(modelData, revenueState, costState, previousMonthState, month);
            
            monthlyResults.push(fullState);
            previousMonthState = fullState;
            cumulativeCFO += fullState.cashFlow.fromOperations;
            if (!breakEvenFound && cumulativeCFO > 0) {
                financialResults.breakEvenMonth = month;
                breakEvenFound = true;
            }
        }
        
        // Annual Aggregation
        for (let year = 1; year <= 5; year++) {
            const yearStartMonth = (year - 1) * 12;
            const yearEndMonth = year * 12;
            const yearMonthsData = monthlyResults.slice(yearStartMonth, yearEndMonth);
            
            const annualPL = {
                totalRevenue: yearMonthsData.reduce((sum, m) => sum + m.pnl.revenue, 0),
                grossRevenue: yearMonthsData.reduce((sum, m) => sum + m.pnl.grossRevenue, 0),
                discounts: yearMonthsData.reduce((sum, m) => sum + m.pnl.discounts, 0),
                opex: yearMonthsData.reduce((sum, m) => sum + m.pnl.opex, 0),
                cogs: yearMonthsData.reduce((sum, m) => sum + m.pnl.cogs, 0),
                depreciation: yearMonthsData.reduce((sum, m) => sum + m.pnl.depreciation, 0),
                interestExpense: yearMonthsData.reduce((sum, m) => sum + m.pnl.interestExpense, 0),
                taxes: yearMonthsData.reduce((sum, m) => sum + m.pnl.taxes, 0),
                netIncome: yearMonthsData.reduce((sum, m) => sum + m.pnl.netIncome, 0),
            };
            annualPL.ebitda = annualPL.totalRevenue - annualPL.cogs - annualPL.opex;
            annualPL.ebitdaMargin = annualPL.totalRevenue > 0 ? (annualPL.ebitda / annualPL.totalRevenue) : 0;
            financialResults.pl.push(annualPL);
            
            const annualDetailedPL = { 
                revenue: { 
                    services: yearMonthsData.reduce((s, m) => s + m.detailedPL.revenue.services, 0),
                    products: yearMonthsData.reduce((s, m) => s + m.detailedPL.revenue.products, 0),
                    memberships: yearMonthsData.reduce((s, m) => s + m.detailedPL.revenue.memberships, 0),
                    crossSell: yearMonthsData.reduce((s, m) => s + m.detailedPL.revenue.crossSell, 0),
                    byTier: { premium: 0, surgery: 0, mid: 0, basic: 0 },
                    byService: {}
                }, 
                cogs: { 
                    supplies: yearMonthsData.reduce((s, m) => s + m.detailedPL.cogs.supplies, 0),
                    products: yearMonthsData.reduce((s, m) => s + m.detailedPL.cogs.products, 0),
                    energy: yearMonthsData.reduce((s, m) => s + m.detailedPL.cogs.energy, 0),
                },
                opex: {
                    personnel: {
                        fixed: yearMonthsData.reduce((s, m) => s + m.detailedPL.opex.personnel.fixed, 0),
                        variable: yearMonthsData.reduce((s, m) => s + m.detailedPL.opex.personnel.variable, 0),
                    },
                    sucursal: yearMonthsData.reduce((s, m) => s + m.detailedPL.opex.sucursal, 0),
                    corporate: yearMonthsData.reduce((s, m) => s + m.detailedPL.opex.corporate, 0),
                    techTeam: yearMonthsData.reduce((s, m) => s + m.detailedPL.opex.techTeam, 0),
                    ga: yearMonthsData.reduce((s, m) => s + m.detailedPL.opex.ga, 0),
                    marketing: yearMonthsData.reduce((s, m) => s + m.detailedPL.opex.marketing, 0),
                }
            };
            
            yearMonthsData.forEach(monthData => {
                for(const tier in monthData.detailedPL.revenue.byTier) {
                    annualDetailedPL.revenue.byTier[tier] += monthData.detailedPL.revenue.byTier[tier];
                }
                for(const service in monthData.detailedPL.revenue.byService) {
                    annualDetailedPL.revenue.byService[service] = (annualDetailedPL.revenue.byService[service] || 0) + monthData.detailedPL.revenue.byService[service];
                }
            });
            financialResults.detailedPL.push(annualDetailedPL);
            
            const cfo = yearMonthsData.reduce((sum, m) => sum + m.cashFlow.fromOperations, 0);
            const cfi = yearMonthsData.reduce((sum, m) => sum + m.cashFlow.fromInvesting, 0);
            const cff = yearMonthsData.reduce((sum, m) => sum + m.cashFlow.fromFinancing, 0);
            financialResults.cf.push({ cfo, cfi, cff, netCashFlow: cfo + cfi + cff });
            
            const lastMonthOfYear = yearMonthsData[yearMonthsData.length - 1];
            financialResults.bs.push(lastMonthOfYear.balanceSheet);
            
            const { ratio: ltv_cac_ratio, breakdown: ltvCacBreakdown, ltv, cac } = calculateBlendedLtvCac(modelData, yearMonthsData);
            financialResults.kpis.push({
                totalActiveCustomers: lastMonthOfYear.totalActiveCustomers,
                customerBreakdown: lastMonthOfYear.activeCustomers,
                activeSucursales: lastMonthOfYear.activeSucursales,
                ltv_cac_ratio,
                ltvCacBreakdown,
                ltv,
                cac
            });
        }
        
        log('   ‚úÖ    ModelCalc v51.0 COMPLETED');
        return true;
    } catch (error) {
        log(`   ‚ùå    ERROR in ModelCalc: ${error.message}`);
        console.error(error);
        return false;
    }
}
function calculateIRR(cashFlows, maxIterations = 100, tolerance = 1e-6) {
    let guess = 0.1;
    for (let i = 0; i < maxIterations; i++) {
        let npv = 0.0;
        let dNpv = 0.0;
        for (let t = 0; t < cashFlows.length; t++) {
            npv += cashFlows[t] / Math.pow(1 + guess, t);
            dNpv -= t * cashFlows[t] / Math.pow(1 + guess, t + 1);
        }
        if (Math.abs(npv) < tolerance) {
            return guess * 100;
        }
        if (dNpv === 0) break;
        guess -= npv / dNpv;
    }
    return 0; // Failed to converge
}
// ===================================================================
// ===== PHASE 3: USER INTERFACE (UI) LOGIC ==================
// ===================================================================
function log(message) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${message}`;
    debugLogs.unshift(logEntry);
    if (debugLogs.length > 200) debugLogs.pop();
    updateDebugPanel();
}
function updateDebugPanel() {
    const panel = document.getElementById('debug-content');
    if (panel) {
        panel.innerHTML = debugLogs.map(log => `<div style="margin-bottom: 2px; font-size: 10px; border-bottom: 1px dotted #4b5563; padding-bottom: 2px;">${log}</div>`).join('');
    }
}
function toggleDebug() {
    const panel = document.getElementById('debug-info');
    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}
function calculateAIImpact() {
    const originalStates = { ...toggleControls };
    // Calculate with all AI ON
    toggleControls.OptiVigenteAI = true;
    toggleControls.MarketingVigenteAI = true;
    toggleControls.PersonaVigenteAI = true;
    calculateFinancials();
    const withAI = {
        revenue: financialResults.pl.length > 4 ? financialResults.pl[4].totalRevenue : 0,
    };
    
    // Calculate with all AI OFF
    toggleControls.OptiVigenteAI = false;
    toggleControls.MarketingVigenteAI = false;
    toggleControls.PersonaVigenteAI = false;
    calculateFinancials();
    const withoutAI = {
        revenue: financialResults.pl.length > 4 ? financialResults.pl[4].totalRevenue : 0,
    };
    
    // Restore original toggle states and recalculate for the UI
    toggleControls = { ...originalStates };
    calculateFinancials();
    
    const revenueUpliftValue = withoutAI.revenue > 0 ? ((withAI.revenue - withoutAI.revenue) / withoutAI.revenue * 100) : 0;
    
    return {
        revenueUplift: revenueUpliftValue.toFixed(1)
    };
}
function buildEquityCashFlows() {
    const equityInvested = modelData.capitalStructure.equityRounds.reduce((sum, r) => sum + r.amount, 0);
    const cashFlows = [-equityInvested];
    
    financialResults.cf.forEach(year => {
        cashFlows.push(year.cfo);
    });
    
    const terminalValue = financialResults.pl[4].ebitda * 15; // 15x multiple
    const debtRemaining = financialResults.bs[4].debt.total;
    const equityValue = terminalValue - debtRemaining;
    cashFlows[cashFlows.length - 1] += equityValue;
    
    return cashFlows;
}
function calculateTIRForMultiple(multiple) {
    const equityInvested = modelData.capitalStructure.equityRounds.reduce((sum, r) => sum + r.amount, 0);
    if (equityInvested === 0) return 0;
    const cashFlows = [ -equityInvested ];
    for (let i = 0; i < 4; i++) {
        cashFlows.push(financialResults.cf[i].cfo);
    }
    const terminalValue = financialResults.pl[4].ebitda * multiple;
    const debtRemaining = financialResults.bs[4].debt.total;
    const terminalEquityValue = terminalValue - debtRemaining;
    cashFlows.push(financialResults.cf[4].cfo + terminalEquityValue);
    
    return calculateIRR(cashFlows);
}
function getCurrentCrossSellRate() {
    if (!toggleControls.PersonaVigenteAI) {
        return 0;
    }
    return modelData.aiDefaults.crossSellBoost;
}
function calculateSpecialistMonthlyEarnings() {
    if (!financialResults.pl[4] || !financialResults.kpis[4]) return 0;
    const totalRevenue = financialResults.pl[4].totalRevenue / 12;
    const premiumServiceRevenue = totalRevenue * 0.6;
    const specialistShare = premiumServiceRevenue * 0.35;
    const numSpecialists = financialResults.kpis[4].activeSucursales * 2;
    
    return numSpecialists > 0 ? specialistShare / numSpecialists : 0;
}
function countActiveAIAgents() {
    let count = 0;
    if (toggleControls.OptiVigenteAI) count++;
    if (toggleControls.MarketingVigenteAI) count++;
    if (toggleControls.PersonaVigenteAI) count++;
    // count += 3; // Simulating other base agents
    return count;
}
//   üî•   V50.1 HELPER: Calculates Gross Margin for an archetype
function calculateGrossMarginPerCustomer(modelData, archetypeKey) {
    const journey = customerJourneyInitial[archetypeKey]; // Use initial for this calculation
    if (!journey) return 0;
    let annualRevenue = 0;
    let annualCogs = 0;
    const realismFactor = modelData.customerBehavior?.realismFactor || 1.0;
    for (const service of modelData.pricing.services) {
        const adoptionRate = (journey[service.name] || 0) * realismFactor;
        if (adoptionRate > 0 && service.repurchaseCycleMonths > 0) {
            const adherenceTier = service.adherenceTier || 'high';
            const adherenceFactor = modelData.adherenceMatrix[archetypeKey]?.[adherenceTier] || 0.75;
            const annualFrequency = (12 / service.repurchaseCycleMonths) * adherenceFactor;
            annualRevenue += adoptionRate * annualFrequency * service.defaultPrice;
            annualCogs += adoptionRate * annualFrequency * service.suppliesCost;
        }
    }
    return annualRevenue - annualCogs;
}
//   üî•   V50.1 REBUILT: Calculates a true LTV based on Gross Margin and Churn
function calculateBlendedLtvCac(modelData, yearMonthsData) {
    let totalWeightedGrossMargin = 0;
    let totalWeightedChurn = 0;
    const paidArchetypes = ['carlos', 'eduardo', 'mantenimiento'];
    const totalPaidPercentage = paidArchetypes.reduce((sum, arch) => sum + (modelData.customerArchetypes[arch].percentage || 0), 0);
    
    paidArchetypes.forEach(archetypeKey => {
        const archetypeData = modelData.customerArchetypes[archetypeKey];
        const grossMargin = calculateGrossMarginPerCustomer(modelData, archetypeKey);
        const reweightedPercentage = archetypeData.percentage / totalPaidPercentage;
        totalWeightedGrossMargin += grossMargin * reweightedPercentage;
        totalWeightedChurn += archetypeData.churnRate * reweightedPercentage;
    });
    
    const blendedLTV = totalWeightedChurn > 0 ? totalWeightedGrossMargin / totalWeightedChurn : 0;
    
    const totalMarketingSpend = yearMonthsData.reduce((sum, m) => sum + (m.pnl.marketingSpend || 0), 0);
    const totalNewPaidCustomers = yearMonthsData.reduce((sum, m) => {
        let monthlyPaidOnly = 0;
        paidArchetypes.forEach(archetype => {
            monthlyPaidOnly += m.newCustomersPaid?.[archetype] || 0;
        });
        return sum + monthlyPaidOnly;
    }, 0);
    
    const blendedCAC = totalNewPaidCustomers > 0 ? totalMarketingSpend / totalNewPaidCustomers : 0;
    const ratio = blendedCAC > 0 ? blendedLTV / blendedCAC : 0;
    
    const breakdown = `LTV Ponderado (Pagados): ${formatCurrency(blendedLTV)}\n` +
        `  - Margen Bruto Anual Ponderado: ${formatCurrency(totalWeightedGrossMargin)}\n` +
        `  - Tasa de Churn Anual Ponderada: ${(totalWeightedChurn * 100).toFixed(1)}%\n` +
        `CAC Real (Pagados): ${formatCurrency(blendedCAC)}`;
    
    log(`   üîç   LTV DEBUG: Blended GM: ${formatCurrency(totalWeightedGrossMargin)}, Blended Churn: ${totalWeightedChurn.toFixed(2)}, Calculated LTV: ${formatCurrency(blendedLTV)}`);
    return { ratio, breakdown, ltv: blendedLTV, cac: blendedCAC };
}
function formatCustomerBreakdown(breakdown) {
    let tooltipText = 'Desglose de Clientes Activos (A√±o 5):\n';
    for (const key in breakdown) {
        tooltipText += `${key.charAt(0).toUpperCase() + key.slice(1)}: ${Math.round(breakdown[key]).toLocaleString()}\n`;
    }
    return tooltipText.trim();
}
// V50.2 HELPER: Calculate and update the Unit Economics display
function updateUnitEconomics() {
    const { capexSucursal } = modelData;
    const remodelCost = capexSucursal.remodelCostPerM2 * capexSucursal.clinicSizeM2;
    const equipmentCost = capexSucursal.equipmentList.reduce((sum, item) => {
        const price = capexSucursal.equipmentStrategy === 'reacondicionado' ? (item.priceReacondicionado || item.priceNew) : item.priceNew;
        return sum + price;
    }, 0);
    const totalCapex = remodelCost + equipmentCost;
    const display = document.getElementById('capex-per-location-display');
    if (display) {
        display.textContent = formatCurrency(totalCapex);
    }
}
function updateUI() {
    log('            üîÑ             Updating Dashboard Interface...');
    try {
        if (!financialResults.pl || financialResults.pl.length < 5) {
             log('            ‚ö†Ô∏è             Financial results not ready for UI update.');
             return;
        }
        
        const aiImpact = calculateAIImpact();
        const ebitdaY5 = financialResults.pl[4].ebitda;
        const currentMultiple = parseFloat(document.getElementById('exit-multiple-slider').value);
        
        const totalDebtUsed = modelData.capitalStructure.debtFacilities.reduce((sum, facility) => sum + facility.amountDrawn, 0);
        const seedAmount = modelData.capitalStructure.equityRounds[0].amount;
        const seriesAAmount = modelData.capitalStructure.equityRounds[1].amount;
        const equityInvested = seedAmount + seriesAAmount;
        const selfFinanced = financialResults.cf.reduce((sum, year) => sum + Math.max(0, year.cfo), 0);
        const locationsY5 = financialResults.kpis[4].activeSucursales;
        const customersY5 = financialResults.kpis[4].totalActiveCustomers;
        const customerBreakdown = financialResults.kpis[4].customerBreakdown;
        const customerDensity = locationsY5 > 0 ? Math.round(customersY5 / locationsY5) : 0;
        const revenuePerCustomer = customersY5 > 0 ? financialResults.pl[4].totalRevenue / customersY5 : 0;
        const revenuePerLocation = locationsY5 > 0 ? financialResults.pl[4].totalRevenue / locationsY5 : 0;
        
        const ltvY5 = financialResults.kpis[4].ltv;
        const cacY5 = financialResults.kpis[4].cac;
        document.getElementById('equity-invested').textContent = formatCurrency(equityInvested);
        document.getElementById('equity-seed').textContent = formatCurrency(seedAmount);
        document.getElementById('equity-series-a').textContent = formatCurrency(seriesAAmount);
        document.getElementById('break-even-month').textContent = financialResults.breakEvenMonth ? `Mes ${financialResults.breakEvenMonth}` : 'N/A';
        document.getElementById('debt-used').textContent = formatCurrency(totalDebtUsed);
        document.getElementById('self-financed').textContent = formatCurrency(selfFinanced);
        document.getElementById('exit-valuation').textContent = formatCurrency(ebitdaY5 * currentMultiple);
        document.getElementById('money-multiple').textContent = equityInvested > 0 ? ((ebitdaY5 * currentMultiple - financialResults.bs[4].debt.total) / equityInvested).toFixed(1) + 'x' : '0x';
        document.getElementById('ebitda-year5-dash').textContent = formatCurrency(ebitdaY5);
        document.getElementById('implied-tir').textContent = calculateTIRForMultiple(currentMultiple).toFixed(1) + '%';
        
        document.getElementById('locations-y5').textContent = locationsY5;
        document.getElementById('customers-y5').textContent = Math.round(customersY5).toLocaleString();
        document.getElementById('customers-y5-wrapper').dataset.tooltip = formatCustomerBreakdown(customerBreakdown);
        document.getElementById('ltv-cac-ratio').textContent = financialResults.kpis[4].ltv_cac_ratio.toFixed(1) + 'x';
        document.getElementById('ltv-cac-tooltip-wrapper').dataset.tooltip = financialResults.kpis[4].ltvCacBreakdown;
        document.getElementById('customer-density').textContent = customerDensity;
        
        document.getElementById('ltv-value').textContent = formatCurrency(ltvY5);
        document.getElementById('cac-value').textContent = formatCurrency(cacY5);
        document.getElementById('revenue-per-location').textContent = formatCurrency(revenuePerLocation);
        document.getElementById('cross-sell-boost').textContent = '+' + (modelData.aiDefaults.crossSellBoost * 100).toFixed(0) + '%';
        document.getElementById('utilization-actual').textContent = (modelData.capacity.targetUtilization * 100).toFixed(0) + '%';
        document.getElementById('revenue-per-customer').textContent = formatCurrency(revenuePerCustomer);
        document.getElementById('specialist-earnings').textContent = formatCurrency(calculateSpecialistMonthlyEarnings());
        document.getElementById('agents-active').textContent = countActiveAIAgents() + '/3';
        
        updateUnitEconomics();
        updateTables();
        updateCharts();
        log('            ‚úÖ             Dashboard UI Update completed.');
    } catch (error) {
        log(`            ‚ùå             Error in updateUI: ${error.message}`);
        console.error(error);
    }
}
function updateTables() {
    updatePLTable();
    updateCashFlowTable();
    updateBalanceSheetTable();
}
function updatePLTable() {
    const tbody = document.getElementById('pl-table-body');
    if (!tbody || !financialResults.pl.length) return;
    tbody.innerHTML = '';
    const createRow = (data) => {
        const tr = document.createElement('tr');
        tr.className = data.classes || '';
        if (data.isSub) tr.classList.add('sub-row');
        if (data.isSubSub) tr.classList.add('sub-sub-row');
        if (data.isSubSubSub) tr.classList.add('sub-sub-sub-row');
        if (data.isTotal) tr.classList.add('total-row');
        if (data.isNetRevenue) tr.classList.add('net-revenue-row');
        if (data.isExpandable) tr.classList.add('expandable');
        if (data.parentId) tr.dataset.parent = data.parentId;
        if (data.id) tr.id = data.id;
        const labelCell = document.createElement('td');
        if (data.isExpandable) {
            labelCell.innerHTML = `<i data-lucide="plus-circle" class="expand-icon"></i> ${data.label}`;
        } else {
            labelCell.textContent = data.label;
        }
        tr.appendChild(labelCell);
        data.values.forEach(value => {
            const cell = document.createElement('td');
            if (data.isPercentage) {
                cell.textContent = (value * 100).toFixed(1) + '%';
            } else {
                cell.textContent = formatCurrency(value);
            }
            if (value < 0 && !data.isPercentage) cell.classList.add('negative');
            tr.appendChild(cell);
        });
        tbody.appendChild(tr);
    };
    
    // V50.7 P&L Structure Update
    createRow({ id: 'revenue', label: 'Ingresos Brutos', values: financialResults.pl.map(y => y.grossRevenue), isExpandable: true });
    
    createRow({ parentId: 'revenue', id: 'services-revenue', label: 'Ingresos por Servicios', values: financialResults.detailedPL.map(y => y.revenue.services), isSub: true, isExpandable: true });
    
    // TIER BREAKDOWN
    createRow({ parentId: 'services-revenue', id: 'premium-tier', label: 'Premium Services', values: financialResults.detailedPL.map(y => y.revenue.byTier.premium), isSubSub: true });
    createRow({ parentId: 'services-revenue', id: 'surgery-tier', label: 'Surgery Services', values: financialResults.detailedPL.map(y => y.revenue.byTier.surgery), isSubSub: true });
    createRow({ parentId: 'services-revenue', id: 'mid-tier', label: 'Mid-Tier Services', values: financialResults.detailedPL.map(y => y.revenue.byTier.mid), isSubSub: true });
    createRow({ parentId: 'services-revenue', id: 'basic-tier', label: 'Basic Services', values: financialResults.detailedPL.map(y => y.revenue.byTier.basic), isSubSub: true });
    createRow({ parentId: 'revenue', label: 'Ingresos Membres√≠as', values: financialResults.detailedPL.map(y => y.revenue.memberships), isSub: true });
    createRow({ parentId: 'revenue', label: 'Ingresos Productos (DTC)', values: financialResults.detailedPL.map(y => y.revenue.products), isSub: true });
    
    createRow({ label: '(-) Descuentos (Club)', values: financialResults.pl.map(y => -y.discounts) });
    createRow({ label: 'Ingresos Netos', values: financialResults.pl.map(y => y.totalRevenue), isNetRevenue: true, isTotal: true });
    createRow({ id: 'cogs', label: 'COGS', values: financialResults.pl.map(y => y.cogs), isExpandable: true });
    createRow({ parentId: 'cogs', label: 'COGS - Energ√≠a Equipos', values: financialResults.detailedPL.map(y => y.cogs.energy), isSub: true });
    createRow({ parentId: 'cogs', label: 'COGS - Insumos Servicios', values: financialResults.detailedPL.map(y => y.cogs.supplies), isSub: true });
    createRow({ parentId: 'cogs', label: 'COGS - Productos (DTC)', values: financialResults.detailedPL.map(y => y.cogs.products), isSub: true });
    
    createRow({ label: 'Utilidad Bruta', values: financialResults.pl.map(y => y.totalRevenue - y.cogs), isTotal: true });
    
    createRow({ id: 'opex', label: 'Gastos Operativos (OPEX)', values: financialResults.pl.map(y => y.opex), isExpandable: true });
    const totalPersonnelCost = financialResults.detailedPL.map(y => y.opex.personnel.fixed + y.opex.personnel.variable);
    createRow({ parentId: 'opex', label: 'Gastos de Personal', values: totalPersonnelCost, isSub: true, isExpandable: true, id: 'opex-personnel' });
    createRow({ parentId: 'opex-personnel', label: 'Salarios Fijos', values: financialResults.detailedPL.map(y => y.opex.personnel.fixed), isSubSub: true });
    createRow({ parentId: 'opex-personnel', label: 'Costos Variables (Revenue Share)', values: financialResults.detailedPL.map(y => y.opex.personnel.variable), isSubSub: true });
    
    createRow({ parentId: 'opex', label: 'Gastos de Sucursal', values: financialResults.detailedPL.map(y => y.opex.sucursal), isSub: true });
    createRow({ parentId: 'opex', label: 'Gastos Corporativos y Tec.', values: financialResults.detailedPL.map(y => y.opex.corporate), isSub: true, isExpandable: true, id: 'opex-corp' });
    createRow({ parentId: 'opex-corp', label: 'G&A', values: financialResults.detailedPL.map(y => y.opex.ga), isSubSub: true });
    createRow({ parentId: 'opex-corp', label: 'Equipo de Tecnolog√≠a (I+D)', values: financialResults.detailedPL.map(y => y.opex.techTeam), isSubSub: true });
    createRow({ parentId: 'opex', label: 'Marketing', values: financialResults.detailedPL.map(y => y.opex.marketing), isSub: true });
    
    createRow({ label: 'EBITDA', values: financialResults.pl.map(y => y.ebitda), isTotal: true });
    createRow({ label: 'Margen EBITDA', values: financialResults.pl.map(y => y.ebitdaMargin), isTotal: true, isPercentage: true });
    createRow({ label: 'Depreciaci√≥n', values: financialResults.pl.map(y => y.depreciation) });
    createRow({ label: 'EBIT', values: financialResults.pl.map(y => y.ebitda - y.depreciation), isTotal: true });
    createRow({ label: 'Gastos por Intereses', values: financialResults.pl.map(y => y.interestExpense) });
    createRow({ label: 'Utilidad Neta', values: financialResults.pl.map(y => y.netIncome), isTotal: true });
    tbody.querySelectorAll('.expandable').forEach(row => {
        row.addEventListener('click', (e) => {
            e.stopPropagation();
            const rowId = row.id;
            const subRows = tbody.querySelectorAll(`[data-parent="${rowId}"]`);
            row.classList.toggle('expanded');
            const icon = row.querySelector('.expand-icon');
            const isExpanded = row.classList.contains('expanded');
            
            if (isExpanded) {
                icon.outerHTML = `<i data-lucide="minus-circle" class="expand-icon"></i>`;
            } else {
                icon.outerHTML = `<i data-lucide="plus-circle" class="expand-icon"></i>`;
                const allChildren = tbody.querySelectorAll(`[data-parent^="${rowId}"]`);
                allChildren.forEach(child => {
                    child.style.display = 'none';
                    if(child.classList.contains('expanded')){
                        child.classList.remove('expanded');
                        const childIcon = child.querySelector('.expand-icon');
                        if(childIcon) childIcon.outerHTML = `<i data-lucide="plus-circle" class="expand-icon"></i>`;
                    }
                });
            }
            
            subRows.forEach(subRow => {
                subRow.style.display = isExpanded ? 'table-row' : 'none';
            });
            lucide.createIcons();
        });
    });
    tbody.querySelectorAll('.sub-row, .sub-sub-row, .sub-sub-sub-row').forEach(subRow => {
        subRow.style.display = 'none';
    });
    lucide.createIcons();
}
function updateCashFlowTable() {
    const tbody = document.getElementById('cf-table-body');
    if (!tbody || !financialResults.cf.length) return;
    tbody.innerHTML = '';
     const rows = [
        { label: 'Flujo Operativo (CFO)', key: 'cfo', total: true },
        { label: 'Flujo de Inversi√≥n (CFI)', key: 'cfi', total: true, negative: true },
        { label: 'Flujo de Financiamiento (CFF)', key: 'cff', total: true },
        { label: 'Flujo Neto de Efectivo', key: 'netCashFlow', total: true, emphasize: true },
        { label: 'Efectivo al Final', key: 'cash', fromBS: true, total: true, emphasize: true }
    ];
    rows.forEach(row => {
        const tr = document.createElement('tr');
        if (row.emphasize) tr.classList.add('total-row');
        const labelCell = document.createElement('td');
        labelCell.textContent = row.label;
        tr.appendChild(labelCell);
        
        const cell0 = document.createElement('td');
        const seedCapital = modelData.capitalStructure.equityRounds.find(r => r.round === "Seed").amount;
        if(row.key === 'cff' || row.key === 'netCashFlow' || row.key === 'cash') {
            cell0.textContent = formatCurrency(seedCapital);
        } else {
            cell0.textContent = formatCurrency(0);
        }
        tr.appendChild(cell0);
        for(let i=0; i<5; i++) {
             const cell = document.createElement('td');
             let value = row.fromBS ? financialResults.bs[i].cash : financialResults.cf[i][row.key];
             cell.textContent = formatCurrency(value);
             if (row.negative && value > 0) cell.textContent = `(${formatCurrency(value)})`;
             if (value < 0) cell.classList.add('negative');
             else if (value > 0 && !row.negative) cell.classList.add('positive');
             tr.appendChild(cell);
        }
        tbody.appendChild(tr);
    });
}
function updateBalanceSheetTable() {
    const tbody = document.getElementById('bs-table-body');
    if (!tbody || !financialResults.bs.length) return;
    tbody.innerHTML = '';
    const rows = [
        { label: 'Efectivo', key: 'cash' },
        { label: 'Activos Fijos (Neto)', key: 'fixedAssets' },
        { label: 'Activos Tecnol√≥gicos (Neto)', key: 'techAssets' }, 
        { label: 'TOTAL ACTIVOS', key: 'totalAssets', total: true, emphasize: true },
        { label: 'Deuda', key: 'debt' },
        { label: 'TOTAL PASIVOS', key: 'debt', total: true },
        { label: 'Patrimonio', key: 'equity' },
        { label: 'TOTAL PASIVOS + PATRIMONIO', key: 'totalLiabilitiesAndEquity', total: true, emphasize: true }
    ];
     rows.forEach(row => {
        const tr = document.createElement('tr');
        if (row.emphasize) tr.classList.add('total-row');
        const labelCell = document.createElement('td');
        labelCell.textContent = row.label;
        tr.appendChild(labelCell);
        
        financialResults.bs.forEach((yearBS, i) => {
            const cell = document.createElement('td');
            let value;
            if (row.key === 'debt') {
                value = yearBS.debt.total;
            } else {
                value = yearBS[row.key] || 0;
            }
            cell.textContent = formatCurrency(value);
            tr.appendChild(cell);
        });
        tbody.appendChild(tr);
    });
    const validationDiv = document.getElementById('balance-validation');
    if (financialResults.bs.length > 0) {
        const lastBS = financialResults.bs[financialResults.bs.length - 1];
        const balanceDiff = lastBS.totalAssets - lastBS.totalLiabilitiesAndEquity;
        if (Math.abs(balanceDiff) < BALANCE_TOLERANCE) {
            validationDiv.innerHTML = '<span class="text-green-400">   ‚úÖ    Balance Validado</span>';
        } else {
            validationDiv.innerHTML = `<span class="text-red-400">   ‚ùå    Error de Balance: ${formatCurrency(balanceDiff)}</span>`;
        }
    }
}
function initializeCharts() {
    Object.values(charts).forEach(chart => chart.destroy());
    const chartOptions = {
        responsive: true, maintainAspectRatio: false,
        plugins: { legend: { position: 'top', labels: { color: '#9ca3af' } } },
        scales: {
            x: { ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
            y: { ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
        }
    };
    
    charts.revenue = new Chart(document.getElementById('revenueEvolutionChart'), { type: 'bar', options: chartOptions });
    charts.profitability = new Chart(document.getElementById('profitabilityChart'), { type: 'line', options: chartOptions });
    charts.customer = new Chart(document.getElementById('customerGrowthChart'), { type: 'line', options: chartOptions });
    charts.cashflow = new Chart(document.getElementById('cashFlowChart'), { type: 'bar', options: chartOptions });
}
function updateCharts() {
    if (!financialResults.pl.length) return;
    const labels = ['A√±o 1', 'A√±o 2', 'A√±o 3', 'A√±o 4', 'A√±o 5'];
    
    charts.revenue.data = {
        labels,
        datasets: [{ label: 'Ingresos Netos', data: financialResults.pl.map(p => p.totalRevenue), backgroundColor: 'rgba(59, 130, 246, 0.6)' }]
    };
    charts.revenue.update();
    charts.profitability.data = {
        labels,
        datasets: [
            { label: 'EBITDA', data: financialResults.pl.map(p => p.ebitda), borderColor: '#3b82f6', fill: false },
            { label: 'Utilidad Neta', data: financialResults.pl.map(p => p.netIncome), borderColor: '#10b981', fill: false }
        ]
    };
    charts.profitability.update();
    
    charts.customer.data = {
        labels,
        datasets: [{ label: 'Clientes Activos (Fin de A√±o)', data: financialResults.kpis.map(k => k.totalActiveCustomers), borderColor: '#0ea5e9', backgroundColor: 'rgba(14, 165, 233, 0.2)', fill: true, tension: 0.3 }]
    };
    charts.customer.update();
    charts.cashflow.data = {
        labels,
        datasets: [
            { label: 'Operativo', data: financialResults.cf.map(c => c.cfo), backgroundColor: '#10b981' },
            { label: 'Inversi√≥n', data: financialResults.cf.map(c => c.cfi), backgroundColor: '#f43f5e' },
            { label: 'Financiamiento', data: financialResults.cf.map(c => c.cff), backgroundColor: '#0ea5e9' }
        ]
    };
    charts.cashflow.options.scales.y.stacked = true;
    charts.cashflow.options.scales.x.stacked = true;
    charts.cashflow.update();
}
function forceCalculate() {
    log('            üîÑ             Manual recalculation requested.');
    if (calculateFinancials()) {
        updateUI();
    } else {
        log('            ‚ùå             Manual recalculation failed.');
    }
}
function getModelValue(pathParts) {
    try {
        let currentValue = modelData;
        for (const part of pathParts) {
            if (currentValue && !isNaN(part)) { currentValue = currentValue[parseInt(part)]; } 
            else if (currentValue && currentValue[part] !== undefined) { currentValue = currentValue[part]; } 
            else { console.warn(`Path not found: ${pathParts.join('.')} at part: ${part}`); return null; }
        }
        return currentValue;
    } catch (error) {
        console.error(`Error reading model value for path ${pathParts.join('.')}: ${error.message}`);
        return null;
    }
}
function updateModelValue(pathParts, value) {
    try {
        let modelRef = modelData;
        const lastKey = pathParts[pathParts.length - 1];
        
        for (let i = 0; i < pathParts.length - 1; i++) {
            const part = pathParts[i];
            if (modelRef && !isNaN(part)) { modelRef = modelRef[parseInt(part)]; } 
            else if (modelRef && modelRef[part] !== undefined) { modelRef = modelRef[part]; } 
            else { console.error(`Path not found: ${pathParts.slice(0, i+1).join('.')}`); return false; }
        }
        
        if (modelRef) {
            if (!isNaN(lastKey)) { modelRef[parseInt(lastKey)] = value; } 
            else { modelRef[lastKey] = value; }
            return true;
        }
        return false;
    } catch (error) {
        console.error(`Error updating model value for path ${pathParts.join('.')}: ${error.message}`);
        return false;
    }
}
function createSelectControl(config, container) {
    const div = document.createElement('div');
    div.className = 'grid grid-cols-1 md:grid-cols-2 gap-y-1 gap-x-4 items-center';
    const label = document.createElement('label');
    label.className = "text-sm font-medium text-slate-300";
    if (config.tooltip) label.setAttribute('data-tooltip', config.tooltip);
    label.textContent = config.label;
    div.appendChild(label);
    
    const select = document.createElement('select');
    select.className = "p-2 border border-gray-600 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 bg-gray-700 text-white w-full";
    config.options.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt.charAt(0).toUpperCase() + opt.slice(1);
        select.appendChild(option);
    });
    const pathParts = config.path.split('.');
    select.value = getModelValue(pathParts) || config.options[0];
    div.appendChild(select);
    container.appendChild(div);
    select.addEventListener('change', function() {
        if (updateModelValue(pathParts, this.value)) {
            forceCalculate();
        }
    });
}
function createSliderControl(config, container) {
    const div = document.createElement('div');
    div.className = 'grid grid-cols-1 md:grid-cols-2 gap-y-1 gap-x-4 items-center';
    const label = document.createElement('label');
    label.className = "text-sm font-medium text-slate-300";
    if (config.tooltip) label.setAttribute('data-tooltip', config.tooltip);
    label.textContent = config.label;
    div.appendChild(label);
    
    const sliderContainer = document.createElement('div');
    sliderContainer.className = 'flex items-center gap-4 w-full';
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = config.min;
    slider.max = config.max;
    slider.step = config.step;
    slider.className = 'input-slider flex-grow';
    
    const display = document.createElement('span');
    display.className = "font-bold text-blue-400 w-40 text-right"; 
    
    const pathParts = config.path.split('.');
    const currentValue = getModelValue(pathParts) || config.min;
    slider.value = currentValue;
    display.textContent = config.format(currentValue);
    
    sliderContainer.appendChild(slider);
    sliderContainer.appendChild(display);
    
    div.appendChild(sliderContainer);
    container.appendChild(div);
    slider.addEventListener('input', function() {
        let value = parseFloat(this.value);
        if (updateModelValue(pathParts, value)) {
            display.textContent = config.format(value);
            forceCalculate();
        }
    });
}
function createNumberControl(config, container) {
    const div = document.createElement('div');
    div.className = 'grid grid-cols-1 md:grid-cols-2 gap-y-1 gap-x-4 items-center';
    const label = document.createElement('label');
    label.className = "text-sm font-medium text-slate-300";
    if (config.tooltip) label.setAttribute('data-tooltip', config.tooltip);
    label.textContent = config.label;
    div.appendChild(label);
    const input = document.createElement('input');
    input.type = 'number';
    input.min = config.min;
    input.max = config.max;
    input.step = config.step;
    input.className = "p-2 border border-gray-600 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 bg-gray-700 text-white w-full";
    
    const pathParts = config.path.split('.');
    const currentValue = getModelValue(pathParts) || config.min;
    input.value = currentValue;
    
    div.appendChild(input);
    container.appendChild(div);
    input.addEventListener('change', function() {
        let value = parseFloat(this.value);
        if (updateModelValue(pathParts, value)) {
            forceCalculate();
        }
    });
}
function createToggleControl(config, container, controlId) {
    const div = document.createElement('div');
    div.className = 'ia-control-item';

    const header = document.createElement('div');
    header.className = 'ia-control-header';

    const label = document.createElement('label');
    label.htmlFor = controlId;
    label.className = "text-sm font-medium text-slate-300";
    label.textContent = config.label;

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = controlId;
    checkbox.checked = toggleControls[controlId];
    checkbox.className = 'w-5 h-5 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500';
    
    header.appendChild(label);
    header.appendChild(checkbox);

    const description = document.createElement('p');
    description.className = 'ia-control-description';
    description.textContent = config.description;

    div.appendChild(header);
    div.appendChild(description);
    container.appendChild(div);

    checkbox.addEventListener('change', function() {
        toggleControls[controlId] = this.checked;
        forceCalculate();
    });
}
function createScenarioSwitcher(config, container){
    const switcher = document.createElement('div');
    switcher.className = 'scenario-switcher';
    
    ['pessimistic', 'base', 'optimistic'].forEach(scenarioName => {
        const input = document.createElement('input');
        input.type = 'radio';
        input.id = `scenario-${scenarioName}`;
        input.name = 'scenario';
        input.value = scenarioName;
        if (scenarioName === 'base') {
            input.checked = true;
        }
        
        const label = document.createElement('label');
        label.htmlFor = `scenario-${scenarioName}`;
        label.textContent = scenarioName.charAt(0).toUpperCase() + scenarioName.slice(1);
        
        switcher.appendChild(input);
        switcher.appendChild(label);
        
        input.addEventListener('change', () => {
            if (input.checked) {
                applyScenario(scenarioName);
            }
        });
    });
    
    container.appendChild(switcher);
}
function setupControlGroup(groupKey, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';
    const groupConfig = controlsConfig[groupKey];

    if (groupKey === 'IA_Native_Controls') {
        // Handle IA_Native_Controls as an object
        for (const controlId in groupConfig) {
            const config = groupConfig[controlId];
            createToggleControl(config, container, controlId);
        }
    } else {
        // Handle other control groups as arrays
        if (!Array.isArray(groupConfig)) {
            console.error(`Expected array for ${groupKey}, but got:`, typeof groupConfig);
            return;
        }
        
        groupConfig.forEach(config => {
            const pathMapping = {
                'seedCapital': 'capitalStructure.equityRounds.0.amount',
                'seriesACapital': 'capitalStructure.equityRounds.1.amount',
                'ventureDebtRate': 'capitalStructure.debtFacilities.0.interestRate',
                'equipmentStrategy': 'capexSucursal.equipmentStrategy',
                'clinicSizeM2': 'capexSucursal.clinicSizeM2',
                'remodelCostPerM2': 'capexSucursal.remodelCostPerM2',
                'sustainBudgetPerLocation': 'marketing.sustainBudgetPerLocation',
                'strategicFocus': 'marketingVigente.strategicFocus',
                'wordOfMouthMultiplierEduardo': 'marketingChannels.eduardoFunnel.wordOfMouthMultiplier',
                'targetUtilization': 'capacity.targetUtilization',
                'funnelConversionRate': 'realismLevers.funnelConversionRate',
                'adherenceUltra': 'customerBehavior.adherenceMultipliers.ultra',
                'adherenceHigh': 'customerBehavior.adherenceMultipliers.high',
                'adherencePremium': 'customerBehavior.adherenceMultipliers.premium',
                'adherenceLuxury': 'customerBehavior.adherenceMultipliers.luxury',
                'churnRateCarlos': 'customerArchetypes.carlos.churnRate',
                'churnRateEduardo': 'customerArchetypes.eduardo.churnRate',
                'churnRateMantenimiento': 'customerArchetypes.mantenimiento.churnRate',
                'churnRateTransaccional': 'customerArchetypes.transaccional.churnRate',
                'treatmentRooms': 'capacity.treatmentRooms',
                'membershipPriceAccess': 'pricing.membership.access.price',
                'membershipAdoptionAccess': 'pricing.membership.access.adoptionRate',
                'membershipPriceElite': 'pricing.membership.elite.price',
                'membershipAdoptionElite': 'pricing.membership.elite.adoptionRate',
                'dtcSpend': 'productsRevenue.avgSpendPerCustomerPerMonth',
                'bnplUplift': 'pricing.bnpl.revenueUpliftMultiplier',
                'specialistRevenueShare': 'opexSucursal.labor.medicoEsteticista.revenueShare',
                'realismFactor': 'customerBehavior.realismFactor',
                'cohortMaturityMonths': 'customerBehavior.cohortMaturityMonths'
            };
            
            config.path = pathMapping[config.id] || config.id;
            if (config.type === 'scenario') { createScenarioSwitcher(config, container); }
            else if (config.type === 'range') { createSliderControl(config, container); } 
            else if (config.type === 'number') { createNumberControl(config, container); }
            else if (config.type === 'select') { createSelectControl(config, container); }
            else if (config.type === 'toggle') { createToggleControl(config, container, config.id); }
        });
    }
}
function applyScenario(scenarioName) {
    const isObject = item => item && typeof item === 'object' && !Array.isArray(item);
    function mergeDeep(target, source) {
        let output = { ...target };
        if (isObject(target) && isObject(source)) {
            Object.keys(source).forEach(key => {
                if (isObject(source[key]) && key in target && isObject(target[key])) {
                    output[key] = mergeDeep(target[key], source[key]);
                } else {
                    output[key] = source[key];
                }
            });
        }
        return output;
    }
    
    const scenarioConfig = scenarios[scenarioName];
    modelData = mergeDeep(JSON.parse(JSON.stringify(baseModelData)), scenarioConfig);
    
    log(`            üìä             Escenario "${scenarioName}" aplicado.`);
    
    // Update sliders to reflect the new modelData
    setupControls();
    forceCalculate();
}
function setupControls() {
    setupControlGroup('growth_engine', 'growth-engine-controls');
    setupControlGroup('capital_strategy', 'capital-strategy-controls');
    setupControlGroup('operations', 'operations-controls');
    setupControlGroup('monetization', 'monetization-controls');
    setupControlGroup('customer_dynamics', 'customer-dynamics-controls');
    setupControlGroup('assumptions', 'assumptions-controls');
    setupControlGroup('IA_Native_Controls', 'ai-native-controls');
}
function setupExitMultipleSlider() {
    const slider = document.getElementById('exit-multiple-slider');
    const display = document.getElementById('exit-multiple-display');
    
    if (slider && display) {
        slider.addEventListener('input', function() {
            const multiple = parseFloat(this.value);
            display.textContent = multiple.toFixed(1) + 'x';
            
            if (financialResults.pl && financialResults.pl.length >= 5) {
                const ebitdaY5 = financialResults.pl[4].ebitda;
                const debtRemaining = financialResults.bs[4].debt.total;
                const equityInvested = modelData.capitalStructure.equityRounds.reduce((sum, r) => sum + r.amount, 0);
                
                const exitValuation = ebitdaY5 * multiple;
                const equityValue = exitValuation - debtRemaining;
                const moneyMultiple = equityInvested > 0 ? equityValue / equityInvested : 0;
                const impliedTIR = calculateTIRForMultiple(multiple);
                
                document.getElementById('exit-valuation').textContent = formatCurrency(exitValuation);
                document.getElementById('money-multiple').textContent = moneyMultiple.toFixed(1) + 'x';
                document.getElementById('implied-tir').textContent = impliedTIR.toFixed(1) + '%';
            }
        });
    }
}
function setupTabs() {
    const tabButtons = document.querySelectorAll('.tab-button');
    const contentSections = document.querySelectorAll('.content-section');
    tabButtons.forEach((button, index) => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            contentSections.forEach(section => section.classList.remove('active'));
            button.classList.add('active');
            contentSections[index].classList.add('active');
            if (button.id === 'tab-graficos') {
                setTimeout(() => updateCharts(), 50);
            }
        });
    });
}
// ===================================================================
// ===== GEMINI API INTEGRATION ======================================
// ===================================================================
/**
 * Shows the Gemini modal and sets its title and content.
 * @param {string} title - The title for the modal header.
 * @param {string} content - The HTML content for the modal body.
 */
function showGeminiModal(title, content) {
    document.getElementById('gemini-modal-title').textContent = title;
    document.getElementById('gemini-modal-body').innerHTML = content;
    document.getElementById('gemini-modal').style.display = 'flex';
}
/**
 * Closes the Gemini modal.
 */
function closeGeminiModal() {
    document.getElementById('gemini-modal').style.display = 'none';
}
/**
 * Generic function to call the Gemini API.
 * @param {string} prompt - The prompt to send to the model.
 * @param {boolean} useJson - Whether to request a JSON response.
 * @param {object|null} schema - The JSON schema for the response, if useJson is true.
 * @returns {Promise<string>} - The text response from the API.
 */
async function callGeminiAPI(prompt, useJson = false, schema = null) {
    let userApiKey = document.getElementById('api-key-input').value.trim();
    const defaultApiKey = "AIzaSyC7rMWhotrv2jizIYrzoDNVpDDLmkA"; // Fallback key
    let apiKey = userApiKey ? userApiKey : defaultApiKey; 
    
    const model = "gemini-2.0-flash";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
    
    const payload = {
        contents: [{ role: "user", parts: [{ text: prompt }] }]
    };
    if (useJson && schema) {
        payload.generationConfig = {
            responseMimeType: "application/json",
            responseSchema: schema,
        };
    }
    log(`[GEMINI] Calling API. Using ${userApiKey ? 'user-provided' : 'default'} key.`);
    log(`[GEMINI] Payload (first 200 chars): ${JSON.stringify(payload).substring(0,200)}...`);
    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const responseText = await response.text();
        log(`[GEMINI] Raw response: ${responseText}`);
        if (!response.ok) {
            let errorDetail = responseText;
            try {
                const errorJson = JSON.parse(responseText);
                errorDetail = errorJson.error.message || responseText;
            } catch (e) {
                // Not a JSON error, use the raw text
            }
            throw new Error(`API request failed with status ${response.status}: ${errorDetail}`);
        }
        const result = JSON.parse(responseText);
        
        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content?.parts?.length > 0) {
            return result.candidates[0].content.parts[0].text;
        } else {
            throw new Error("Respuesta inesperada de la API o contenido vac√≠o.");
        }
    } catch (error) {
        console.error("Error calling Gemini API:", error);
        log(`[GEMINI] ERROR: ${error.message}`);
        return `Error al contactar la IA: ${error.message}`;
    }
}
/**
 * V38 CHANGE: Builds a much more comprehensive context string from the model data.
 */
function buildFullModelContext() {
    let context = "### CONTEXTO DEL MODELO FINANCIERO 'HOMBRE VIGENTE' ###\n\n";
    // Helper to format a section
    const formatSection = (title, dataObject) => {
        let sectionContent = `#### ${title} ####\n`;
        sectionContent += "```json\n" + JSON.stringify(dataObject, (key, value) => {
            if (key === 'get maxHoursPerMonth') return undefined; 
            return value;
        }, 2) + "\n```\n\n";
        return sectionContent;
    };
    context += formatSection("Supuestos Generales y de Marketing", {
        general: modelData.general,
        marketing: modelData.marketing,
        marketingChannels: modelData.marketingChannels,
        expansionPlan: modelData.expansionPlan
    });
    context += formatSection("Supuestos de Clientes y LTV", {
        customerArchetypes: modelData.customerArchetypes,
    });
    
    context += formatSection("Supuestos de Pricing, Servicios y Productos", {
        pricing: modelData.pricing,
        productsRevenue: modelData.productsRevenue
    });
    context += formatSection("Supuestos de Costos y Capital", {
        opexSucursal: modelData.opexSucursal,
        opexCorporativo: modelData.opexCorporativo,
        capexSucursal: modelData.capexSucursal,
        capexTecnologico: modelData.capexTecnologico,
        capitalStructure: modelData.capitalStructure
    });
    
    context += formatSection("Supuestos de IA y Operaciones", {
        aiDefaults: modelData.aiDefaults,
        personaVigenteAI: modelData.personaVigenteAI,
        optiVigenteAI: modelData.optiVigenteAI,
        capacity: {
            treatmentRooms: modelData.capacity.treatmentRooms,
            dailyOperatingHours: modelData.capacity.dailyOperatingHours,
            daysOpenPerMonth: modelData.capacity.daysOpenPerMonth,
            targetUtilization: modelData.capacity.targetUtilization,
            maxSurgeriesPerMonth: modelData.capacity.maxSurgeriesPerMonth
        }
    });
    context += "#### Resultados Financieros Clave (Anual) ####\n";
    if (financialResults.pl.length > 0) {
        financialResults.pl.forEach((year, i) => {
            context += `A√±o ${i+1}: Ingresos=${formatCurrency(year.totalRevenue)}, EBITDA=${formatCurrency(year.ebitda)}, Utilidad Neta=${formatCurrency(year.netIncome)}\n`;
        });
    }
     if (financialResults.kpis.length > 4) {
        const kpisY5 = financialResults.kpis[4];
        context += `KPIs Finales (A√±o 5): Sucursales=${kpisY5.activeSucursales}, Clientes=${Math.round(kpisY5.totalActiveCustomers)}, LTV:CAC General=${kpisY5.ltv_cac_ratio.toFixed(1)}x\n`;
     }
    
    return context;
}
/**
 * Opens the strategic copilot modal.
 */
function openCopilotModal() {
    const modalContent = `
        <p class="text-slate-400 mb-4">Haz una pregunta sobre el estado actual del modelo. Por ejemplo: "Sugiere 3 iniciativas para mejorar el EBITDA del a√±o 3" o "¬øPor qu√© cae el n√∫mero de clientes en el a√±o 3?".</p>
        <textarea id="copilot-prompt" class="w-full h-24 p-2 bg-gray-800 border border-gray-600 rounded-md text-white" placeholder="Escribe tu pregunta aqu√≠..."></textarea>
        <div class="text-right mt-4">
            <button onclick="submitCopilotQuery()" class="bg-purple-600 hover:bg-purple-500 text-white px-4 py-2 rounded-lg font-medium">Enviar Pregunta      ‚ú®     </button>
        </div>
        <div id="copilot-response" class="mt-4 p-4 bg-gray-900 rounded-md" style="display:none;"></div>
    `;
    showGeminiModal('Copiloto Estrat√©gico', modalContent);
}
/**
 * Submits the user's query from the copilot modal to the Gemini API.
 */
async function submitCopilotQuery() {
    const userQuery = document.getElementById('copilot-prompt').value;
    if (!userQuery) {
        alert("Por favor, escribe una pregunta.");
        return;
    }
    const responseContainer = document.getElementById('copilot-response');
    responseContainer.style.display = 'block';
    responseContainer.innerHTML = '<div class="loader"></div>';
    const modelContext = buildFullModelContext();
    const fullPrompt = `Como un analista financiero experto (CFA) con profundo conocimiento del negocio, analiza la siguiente data y responde a la pregunta del usuario. Conecta los puntos entre las asunciones (modelData) y los resultados (financialResults) para dar una respuesta detallada y con causa-ra√≠z.
${modelContext}
PREGUNTA DEL USUARIO:
"${userQuery}"
Responde en espa√±ol, usando un tono profesional y directo. Utiliza markdown b√°sico (negritas con **, listas con -) para formatear tu respuesta.`;
    const response = await callGeminiAPI(fullPrompt);
    let htmlResponse = response.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // Bold
    htmlResponse = htmlResponse.replace(/\n/g, '<br>'); // Newlines
    responseContainer.innerHTML = htmlResponse;
}
/**
 * Generates an executive summary of the P&L using the Gemini API.
 */
async function generateExecutiveSummary() {
    showGeminiModal('Generando Resumen Ejecutivo...', '<div class="loader"></div>');
    const modelContext = buildFullModelContext();
    const prompt = `Act√∫a como un analista financiero senior preparando un reporte para la junta directiva de 'Hombre Vigente'. Basado en los siguientes datos del modelo, escribe un resumen ejecutivo conciso.
Enf√≥cate en:
1. La trayectoria de crecimiento de los ingresos y sus drivers.
2. La evoluci√≥n de la rentabilidad (m√°rgenes y EBITDA) y sus causas.
3. Los puntos clave o inflexiones (ej. cu√°ndo se vuelve rentable y por qu√©).
4. Un √°rea potencial de riesgo u oportunidad que se desprenda de los n√∫meros.
DATOS DEL MODELO:
${modelContext}
El resumen debe ser profesional, claro y en espa√±ol.`;
    const summary = await callGeminiAPI(prompt);
    document.getElementById('gemini-modal-title').textContent = 'Resumen Ejecutivo';
    document.getElementById('gemini-modal-body').innerHTML = summary.replace(/\n/g, '<br>');
}
/**
 * Asks Gemini to suggest new services based on current data, requesting a structured JSON response.
 */
async function suggestNewServices() {
    showGeminiModal('Buscando Oportunidades de Crecimiento...', '<div class="loader"></div>');
    const serviceNames = modelData.pricing.services.map(s => s.name).join(', ');
    let archetypeDescriptions = '';
    for (const key in modelData.customerArchetypes) {
        archetypeDescriptions += `- ${key}: ${modelData.customerArchetypes[key].description}\n`;
    }
    const prompt = `Eres un estratega de negocio para una cl√≠nica de est√©tica y bienestar masculino llamada 'Hombre Vigente'. Basado en nuestros arquetipos de cliente y cat√°logo de servicios actuales, sugiere 3 servicios o paquetes de servicios nuevos, innovadores y sin√©rgicos.
Nuestros arquetipos de cliente son:
${archetypeDescriptions}
Nuestro cat√°logo de servicios actual incluye: ${serviceNames}.
Para cada sugerencia, proporciona un nombre, el arquetipo de cliente principal al que se dirige, un precio sugerido en MXN y una justificaci√≥n breve y convincente.`;
    const schema = {
        type: "ARRAY",
        items: {
            type: "OBJECT",
            properties: {
                "serviceName": { "type": "STRING", "description": "Nombre del nuevo servicio o paquete." },
                "targetArchetype": { "type": "STRING", "description": "El arquetipo de cliente principal (ej. 'carlos', 'eduardo')." },
                "suggestedPrice": { "type": "NUMBER", "description": "Precio sugerido en MXN." },
                "justification": { "type": "STRING", "description": "Justificaci√≥n de por qu√© es una buena idea." }
            },
            required: ["serviceName", "targetArchetype", "suggestedPrice", "justification"]
        }
    };
    const responseText = await callGeminiAPI(prompt, true, schema);
    
    try {
        const suggestions = JSON.parse(responseText);
        let htmlOutput = '';
        suggestions.forEach(s => {
            htmlOutput += `
                <div class="mb-4 p-4 border border-gray-600 rounded-lg">
                    <h5 class="text-blue-400">${s.serviceName}</h5>
                    <p><strong>P√∫blico Objetivo:</strong> ${s.targetArchetype}</p>
                    <p><strong>Precio Sugerido:</strong> ${formatCurrency(s.suggestedPrice)}</p>
                    <p><strong>Justificaci√≥n:</strong> ${s.justification}</p>
                </div>
            `;
        });
        document.getElementById('gemini-modal-title').textContent = 'Sugerencias de Nuevos Servicios';
        document.getElementById('gemini-modal-body').innerHTML = htmlOutput;
    } catch (e) {
        console.error("Error parsing JSON from Gemini:", e);
        document.getElementById('gemini-modal-body').innerHTML = `Hubo un error al procesar las sugerencias de la IA. <br><br>Respuesta recibida:<br>${responseText}`;
    }
}
// ===================================================================
// ===== INITIALIZATION ==============================================
// ===================================================================
document.addEventListener('DOMContentLoaded', function() {
    log('            üöÄ             STARTING HOMBRE VIGENTE FINANCIAL MODEL V51.0');
    try {
        setupTabs();
        setupControls();
        setupExitMultipleSlider();
        initializeCharts();
        forceCalculate(); // Initial calculation with the new base scenario
        log('            üéâ             APPLICATION READY');
    } catch (error) {
        log(`            ‚ùå             CRITICAL ERROR DURING INITIALIZATION: ${error.message}`);
        console.error(error);
    }
});
</script>
</body>
</html>
